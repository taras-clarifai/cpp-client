// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/spire/spire.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fspire_2fspire_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fspire_2fspire_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "proto/utils/checkpoint.pb.h"
#include "proto/utils/data_example.pb.h"
#include "proto/utils/data_provider.pb.h"
#include "proto/utils/databatch.pb.h"
#include "proto/utils/request_meta.pb.h"
#include "proto/utils/tag.pb.h"
#include "proto/utils/vocab.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fspire_2fspire_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fspire_2fspire_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[28]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fspire_2fspire_2eproto;
class BBoxCropConfig;
class BBoxCropConfigDefaultTypeInternal;
extern BBoxCropConfigDefaultTypeInternal _BBoxCropConfig_default_instance_;
class CPUResources;
class CPUResourcesDefaultTypeInternal;
extern CPUResourcesDefaultTypeInternal _CPUResources_default_instance_;
class FaceDetectConfig;
class FaceDetectConfigDefaultTypeInternal;
extern FaceDetectConfigDefaultTypeInternal _FaceDetectConfig_default_instance_;
class MultiHeadConfig;
class MultiHeadConfigDefaultTypeInternal;
extern MultiHeadConfigDefaultTypeInternal _MultiHeadConfig_default_instance_;
class Replicas;
class ReplicasDefaultTypeInternal;
extern ReplicasDefaultTypeInternal _Replicas_default_instance_;
class SpireConfig;
class SpireConfigDefaultTypeInternal;
extern SpireConfigDefaultTypeInternal _SpireConfig_default_instance_;
class SpireConfig_CpuResourcesEntry_DoNotUse;
class SpireConfig_CpuResourcesEntry_DoNotUseDefaultTypeInternal;
extern SpireConfig_CpuResourcesEntry_DoNotUseDefaultTypeInternal _SpireConfig_CpuResourcesEntry_DoNotUse_default_instance_;
class SpireConfig_HeadsEntry_DoNotUse;
class SpireConfig_HeadsEntry_DoNotUseDefaultTypeInternal;
extern SpireConfig_HeadsEntry_DoNotUseDefaultTypeInternal _SpireConfig_HeadsEntry_DoNotUse_default_instance_;
class SpireConfig_ReplicasEntry_DoNotUse;
class SpireConfig_ReplicasEntry_DoNotUseDefaultTypeInternal;
extern SpireConfig_ReplicasEntry_DoNotUseDefaultTypeInternal _SpireConfig_ReplicasEntry_DoNotUse_default_instance_;
class SpireDetectEmbedTagRequest;
class SpireDetectEmbedTagRequestDefaultTypeInternal;
extern SpireDetectEmbedTagRequestDefaultTypeInternal _SpireDetectEmbedTagRequest_default_instance_;
class SpireDetectEmbedTagResponse;
class SpireDetectEmbedTagResponseDefaultTypeInternal;
extern SpireDetectEmbedTagResponseDefaultTypeInternal _SpireDetectEmbedTagResponse_default_instance_;
class SpireEmbedTagRequest;
class SpireEmbedTagRequestDefaultTypeInternal;
extern SpireEmbedTagRequestDefaultTypeInternal _SpireEmbedTagRequest_default_instance_;
class SpireEmbedTagResponse;
class SpireEmbedTagResponseDefaultTypeInternal;
extern SpireEmbedTagResponseDefaultTypeInternal _SpireEmbedTagResponse_default_instance_;
class SpireGetConfigRequest;
class SpireGetConfigRequestDefaultTypeInternal;
extern SpireGetConfigRequestDefaultTypeInternal _SpireGetConfigRequest_default_instance_;
class SpireGetConfigResponse;
class SpireGetConfigResponseDefaultTypeInternal;
extern SpireGetConfigResponseDefaultTypeInternal _SpireGetConfigResponse_default_instance_;
class SpireGetStateRequest;
class SpireGetStateRequestDefaultTypeInternal;
extern SpireGetStateRequestDefaultTypeInternal _SpireGetStateRequest_default_instance_;
class SpireGetStateResponse;
class SpireGetStateResponseDefaultTypeInternal;
extern SpireGetStateResponseDefaultTypeInternal _SpireGetStateResponse_default_instance_;
class SpireInstanceSegmentRequest;
class SpireInstanceSegmentRequestDefaultTypeInternal;
extern SpireInstanceSegmentRequestDefaultTypeInternal _SpireInstanceSegmentRequest_default_instance_;
class SpireInstanceSegmentResponse;
class SpireInstanceSegmentResponseDefaultTypeInternal;
extern SpireInstanceSegmentResponseDefaultTypeInternal _SpireInstanceSegmentResponse_default_instance_;
class SpireMaybeJITRequest;
class SpireMaybeJITRequestDefaultTypeInternal;
extern SpireMaybeJITRequestDefaultTypeInternal _SpireMaybeJITRequest_default_instance_;
class SpireMaybeJITResponse;
class SpireMaybeJITResponseDefaultTypeInternal;
extern SpireMaybeJITResponseDefaultTypeInternal _SpireMaybeJITResponse_default_instance_;
class SpireMeta;
class SpireMetaDefaultTypeInternal;
extern SpireMetaDefaultTypeInternal _SpireMeta_default_instance_;
class SpireSavedOutputRequest;
class SpireSavedOutputRequestDefaultTypeInternal;
extern SpireSavedOutputRequestDefaultTypeInternal _SpireSavedOutputRequest_default_instance_;
class SpireSavedOutputResponse;
class SpireSavedOutputResponseDefaultTypeInternal;
extern SpireSavedOutputResponseDefaultTypeInternal _SpireSavedOutputResponse_default_instance_;
class SpireSetConfigRequest;
class SpireSetConfigRequestDefaultTypeInternal;
extern SpireSetConfigRequestDefaultTypeInternal _SpireSetConfigRequest_default_instance_;
class SpireSetConfigResponse;
class SpireSetConfigResponseDefaultTypeInternal;
extern SpireSetConfigResponseDefaultTypeInternal _SpireSetConfigResponse_default_instance_;
class SpireStopServingRequest;
class SpireStopServingRequestDefaultTypeInternal;
extern SpireStopServingRequestDefaultTypeInternal _SpireStopServingRequest_default_instance_;
class SpireStopServingResponse;
class SpireStopServingResponseDefaultTypeInternal;
extern SpireStopServingResponseDefaultTypeInternal _SpireStopServingResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BBoxCropConfig* Arena::CreateMaybeMessage<::BBoxCropConfig>(Arena*);
template<> ::CPUResources* Arena::CreateMaybeMessage<::CPUResources>(Arena*);
template<> ::FaceDetectConfig* Arena::CreateMaybeMessage<::FaceDetectConfig>(Arena*);
template<> ::MultiHeadConfig* Arena::CreateMaybeMessage<::MultiHeadConfig>(Arena*);
template<> ::Replicas* Arena::CreateMaybeMessage<::Replicas>(Arena*);
template<> ::SpireConfig* Arena::CreateMaybeMessage<::SpireConfig>(Arena*);
template<> ::SpireConfig_CpuResourcesEntry_DoNotUse* Arena::CreateMaybeMessage<::SpireConfig_CpuResourcesEntry_DoNotUse>(Arena*);
template<> ::SpireConfig_HeadsEntry_DoNotUse* Arena::CreateMaybeMessage<::SpireConfig_HeadsEntry_DoNotUse>(Arena*);
template<> ::SpireConfig_ReplicasEntry_DoNotUse* Arena::CreateMaybeMessage<::SpireConfig_ReplicasEntry_DoNotUse>(Arena*);
template<> ::SpireDetectEmbedTagRequest* Arena::CreateMaybeMessage<::SpireDetectEmbedTagRequest>(Arena*);
template<> ::SpireDetectEmbedTagResponse* Arena::CreateMaybeMessage<::SpireDetectEmbedTagResponse>(Arena*);
template<> ::SpireEmbedTagRequest* Arena::CreateMaybeMessage<::SpireEmbedTagRequest>(Arena*);
template<> ::SpireEmbedTagResponse* Arena::CreateMaybeMessage<::SpireEmbedTagResponse>(Arena*);
template<> ::SpireGetConfigRequest* Arena::CreateMaybeMessage<::SpireGetConfigRequest>(Arena*);
template<> ::SpireGetConfigResponse* Arena::CreateMaybeMessage<::SpireGetConfigResponse>(Arena*);
template<> ::SpireGetStateRequest* Arena::CreateMaybeMessage<::SpireGetStateRequest>(Arena*);
template<> ::SpireGetStateResponse* Arena::CreateMaybeMessage<::SpireGetStateResponse>(Arena*);
template<> ::SpireInstanceSegmentRequest* Arena::CreateMaybeMessage<::SpireInstanceSegmentRequest>(Arena*);
template<> ::SpireInstanceSegmentResponse* Arena::CreateMaybeMessage<::SpireInstanceSegmentResponse>(Arena*);
template<> ::SpireMaybeJITRequest* Arena::CreateMaybeMessage<::SpireMaybeJITRequest>(Arena*);
template<> ::SpireMaybeJITResponse* Arena::CreateMaybeMessage<::SpireMaybeJITResponse>(Arena*);
template<> ::SpireMeta* Arena::CreateMaybeMessage<::SpireMeta>(Arena*);
template<> ::SpireSavedOutputRequest* Arena::CreateMaybeMessage<::SpireSavedOutputRequest>(Arena*);
template<> ::SpireSavedOutputResponse* Arena::CreateMaybeMessage<::SpireSavedOutputResponse>(Arena*);
template<> ::SpireSetConfigRequest* Arena::CreateMaybeMessage<::SpireSetConfigRequest>(Arena*);
template<> ::SpireSetConfigResponse* Arena::CreateMaybeMessage<::SpireSetConfigResponse>(Arena*);
template<> ::SpireStopServingRequest* Arena::CreateMaybeMessage<::SpireStopServingRequest>(Arena*);
template<> ::SpireStopServingResponse* Arena::CreateMaybeMessage<::SpireStopServingResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum SpireConfig_Framework : int {
  SpireConfig_Framework_TENSORFLOW = 0,
  SpireConfig_Framework_PYTORCH = 1,
  SpireConfig_Framework_SpireConfig_Framework_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SpireConfig_Framework_SpireConfig_Framework_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SpireConfig_Framework_IsValid(int value);
constexpr SpireConfig_Framework SpireConfig_Framework_Framework_MIN = SpireConfig_Framework_TENSORFLOW;
constexpr SpireConfig_Framework SpireConfig_Framework_Framework_MAX = SpireConfig_Framework_PYTORCH;
constexpr int SpireConfig_Framework_Framework_ARRAYSIZE = SpireConfig_Framework_Framework_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpireConfig_Framework_descriptor();
template<typename T>
inline const std::string& SpireConfig_Framework_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpireConfig_Framework>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpireConfig_Framework_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpireConfig_Framework_descriptor(), enum_t_value);
}
inline bool SpireConfig_Framework_Parse(
    const std::string& name, SpireConfig_Framework* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpireConfig_Framework>(
    SpireConfig_Framework_descriptor(), name, value);
}
enum SpireModelType : int {
  NOT_SET = 0,
  CLASSIFICATION = 1,
  DETECTION = 2,
  EMBEDDINGS_CLASSIFICATION = 3,
  SpireModelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SpireModelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SpireModelType_IsValid(int value);
constexpr SpireModelType SpireModelType_MIN = NOT_SET;
constexpr SpireModelType SpireModelType_MAX = EMBEDDINGS_CLASSIFICATION;
constexpr int SpireModelType_ARRAYSIZE = SpireModelType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpireModelType_descriptor();
template<typename T>
inline const std::string& SpireModelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpireModelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpireModelType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpireModelType_descriptor(), enum_t_value);
}
inline bool SpireModelType_Parse(
    const std::string& name, SpireModelType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpireModelType>(
    SpireModelType_descriptor(), name, value);
}
enum SpireSpatialReduceType : int {
  MEAN = 0,
  MAX = 1,
  SpireSpatialReduceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SpireSpatialReduceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SpireSpatialReduceType_IsValid(int value);
constexpr SpireSpatialReduceType SpireSpatialReduceType_MIN = MEAN;
constexpr SpireSpatialReduceType SpireSpatialReduceType_MAX = MAX;
constexpr int SpireSpatialReduceType_ARRAYSIZE = SpireSpatialReduceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpireSpatialReduceType_descriptor();
template<typename T>
inline const std::string& SpireSpatialReduceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpireSpatialReduceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpireSpatialReduceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpireSpatialReduceType_descriptor(), enum_t_value);
}
inline bool SpireSpatialReduceType_Parse(
    const std::string& name, SpireSpatialReduceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpireSpatialReduceType>(
    SpireSpatialReduceType_descriptor(), name, value);
}
enum SpireState : int {
  NONE = 0,
  INITIALIZING = 1,
  READY = 2,
  ERROR = 3,
  SpireState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SpireState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SpireState_IsValid(int value);
constexpr SpireState SpireState_MIN = NONE;
constexpr SpireState SpireState_MAX = ERROR;
constexpr int SpireState_ARRAYSIZE = SpireState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpireState_descriptor();
template<typename T>
inline const std::string& SpireState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpireState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpireState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpireState_descriptor(), enum_t_value);
}
inline bool SpireState_Parse(
    const std::string& name, SpireState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpireState>(
    SpireState_descriptor(), name, value);
}
enum SpireOps : int {
  TAG = 0,
  EMBED = 1,
  FACE_DETECT = 2,
  OCR = 3,
  LANDMARKS = 4,
  SpireOps_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SpireOps_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SpireOps_IsValid(int value);
constexpr SpireOps SpireOps_MIN = TAG;
constexpr SpireOps SpireOps_MAX = LANDMARKS;
constexpr int SpireOps_ARRAYSIZE = SpireOps_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpireOps_descriptor();
template<typename T>
inline const std::string& SpireOps_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpireOps>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpireOps_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpireOps_descriptor(), enum_t_value);
}
inline bool SpireOps_Parse(
    const std::string& name, SpireOps* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpireOps>(
    SpireOps_descriptor(), name, value);
}
// ===================================================================

class FaceDetectConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FaceDetectConfig) */ {
 public:
  FaceDetectConfig();
  virtual ~FaceDetectConfig();

  FaceDetectConfig(const FaceDetectConfig& from);
  FaceDetectConfig(FaceDetectConfig&& from) noexcept
    : FaceDetectConfig() {
    *this = ::std::move(from);
  }

  inline FaceDetectConfig& operator=(const FaceDetectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaceDetectConfig& operator=(FaceDetectConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FaceDetectConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceDetectConfig* internal_default_instance() {
    return reinterpret_cast<const FaceDetectConfig*>(
               &_FaceDetectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FaceDetectConfig& a, FaceDetectConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(FaceDetectConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FaceDetectConfig* New() const final {
    return CreateMaybeMessage<FaceDetectConfig>(nullptr);
  }

  FaceDetectConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FaceDetectConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FaceDetectConfig& from);
  void MergeFrom(const FaceDetectConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceDetectConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FaceDetectConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kSpireConfigFieldNumber = 2,
    kCascadePathFieldNumber = 4,
    kBboxCropFieldNumber = 6,
    kDetectThresholdFieldNumber = 3,
    kMinSizeFieldNumber = 5,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);

  // string spire_config = 2;
  void clear_spire_config();
  const std::string& spire_config() const;
  void set_spire_config(const std::string& value);
  void set_spire_config(std::string&& value);
  void set_spire_config(const char* value);
  void set_spire_config(const char* value, size_t size);
  std::string* mutable_spire_config();
  std::string* release_spire_config();
  void set_allocated_spire_config(std::string* spire_config);

  // string cascade_path = 4;
  void clear_cascade_path();
  const std::string& cascade_path() const;
  void set_cascade_path(const std::string& value);
  void set_cascade_path(std::string&& value);
  void set_cascade_path(const char* value);
  void set_cascade_path(const char* value, size_t size);
  std::string* mutable_cascade_path();
  std::string* release_cascade_path();
  void set_allocated_cascade_path(std::string* cascade_path);

  // .BBoxCropConfig bbox_crop = 6;
  bool has_bbox_crop() const;
  void clear_bbox_crop();
  const ::BBoxCropConfig& bbox_crop() const;
  ::BBoxCropConfig* release_bbox_crop();
  ::BBoxCropConfig* mutable_bbox_crop();
  void set_allocated_bbox_crop(::BBoxCropConfig* bbox_crop);

  // float detect_threshold = 3;
  void clear_detect_threshold();
  float detect_threshold() const;
  void set_detect_threshold(float value);

  // float min_size = 5;
  void clear_min_size();
  float min_size() const;
  void set_min_size(float value);

  // @@protoc_insertion_point(class_scope:FaceDetectConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spire_config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cascade_path_;
  ::BBoxCropConfig* bbox_crop_;
  float detect_threshold_;
  float min_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class BBoxCropConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BBoxCropConfig) */ {
 public:
  BBoxCropConfig();
  virtual ~BBoxCropConfig();

  BBoxCropConfig(const BBoxCropConfig& from);
  BBoxCropConfig(BBoxCropConfig&& from) noexcept
    : BBoxCropConfig() {
    *this = ::std::move(from);
  }

  inline BBoxCropConfig& operator=(const BBoxCropConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BBoxCropConfig& operator=(BBoxCropConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BBoxCropConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BBoxCropConfig* internal_default_instance() {
    return reinterpret_cast<const BBoxCropConfig*>(
               &_BBoxCropConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BBoxCropConfig& a, BBoxCropConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BBoxCropConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BBoxCropConfig* New() const final {
    return CreateMaybeMessage<BBoxCropConfig>(nullptr);
  }

  BBoxCropConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BBoxCropConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BBoxCropConfig& from);
  void MergeFrom(const BBoxCropConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BBoxCropConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BBoxCropConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kMarginFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);

  // float margin = 2;
  void clear_margin();
  float margin() const;
  void set_margin(float value);

  // @@protoc_insertion_point(class_scope:BBoxCropConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  float margin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class MultiHeadConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MultiHeadConfig) */ {
 public:
  MultiHeadConfig();
  virtual ~MultiHeadConfig();

  MultiHeadConfig(const MultiHeadConfig& from);
  MultiHeadConfig(MultiHeadConfig&& from) noexcept
    : MultiHeadConfig() {
    *this = ::std::move(from);
  }

  inline MultiHeadConfig& operator=(const MultiHeadConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiHeadConfig& operator=(MultiHeadConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultiHeadConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiHeadConfig* internal_default_instance() {
    return reinterpret_cast<const MultiHeadConfig*>(
               &_MultiHeadConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MultiHeadConfig& a, MultiHeadConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiHeadConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiHeadConfig* New() const final {
    return CreateMaybeMessage<MultiHeadConfig>(nullptr);
  }

  MultiHeadConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiHeadConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultiHeadConfig& from);
  void MergeFrom(const MultiHeadConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiHeadConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MultiHeadConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatasetFieldNumber = 1,
    kFaceKeyFieldNumber = 2,
    kVocabFieldNumber = 3,
  };
  // string dataset = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_dataset();
  PROTOBUF_DEPRECATED const std::string& dataset() const;
  PROTOBUF_DEPRECATED void set_dataset(const std::string& value);
  PROTOBUF_DEPRECATED void set_dataset(std::string&& value);
  PROTOBUF_DEPRECATED void set_dataset(const char* value);
  PROTOBUF_DEPRECATED void set_dataset(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_dataset();
  PROTOBUF_DEPRECATED std::string* release_dataset();
  PROTOBUF_DEPRECATED void set_allocated_dataset(std::string* dataset);

  // string face_key = 2;
  void clear_face_key();
  const std::string& face_key() const;
  void set_face_key(const std::string& value);
  void set_face_key(std::string&& value);
  void set_face_key(const char* value);
  void set_face_key(const char* value, size_t size);
  std::string* mutable_face_key();
  std::string* release_face_key();
  void set_allocated_face_key(std::string* face_key);

  // .Vocab vocab = 3;
  bool has_vocab() const;
  void clear_vocab();
  const ::Vocab& vocab() const;
  ::Vocab* release_vocab();
  ::Vocab* mutable_vocab();
  void set_allocated_vocab(::Vocab* vocab);

  // @@protoc_insertion_point(class_scope:MultiHeadConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dataset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr face_key_;
  ::Vocab* vocab_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireConfig_HeadsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpireConfig_HeadsEntry_DoNotUse, 
    std::string, ::MultiHeadConfig,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpireConfig_HeadsEntry_DoNotUse, 
    std::string, ::MultiHeadConfig,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SpireConfig_HeadsEntry_DoNotUse();
  SpireConfig_HeadsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpireConfig_HeadsEntry_DoNotUse& other);
  static const SpireConfig_HeadsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpireConfig_HeadsEntry_DoNotUse*>(&_SpireConfig_HeadsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "SpireConfig.HeadsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[3];
  }

  public:
};

// -------------------------------------------------------------------

class SpireConfig_CpuResourcesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpireConfig_CpuResourcesEntry_DoNotUse, 
    std::string, ::CPUResources,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpireConfig_CpuResourcesEntry_DoNotUse, 
    std::string, ::CPUResources,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SpireConfig_CpuResourcesEntry_DoNotUse();
  SpireConfig_CpuResourcesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpireConfig_CpuResourcesEntry_DoNotUse& other);
  static const SpireConfig_CpuResourcesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpireConfig_CpuResourcesEntry_DoNotUse*>(&_SpireConfig_CpuResourcesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "SpireConfig.CpuResourcesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[4];
  }

  public:
};

// -------------------------------------------------------------------

class SpireConfig_ReplicasEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpireConfig_ReplicasEntry_DoNotUse, 
    std::string, ::Replicas,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SpireConfig_ReplicasEntry_DoNotUse, 
    std::string, ::Replicas,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SpireConfig_ReplicasEntry_DoNotUse();
  SpireConfig_ReplicasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SpireConfig_ReplicasEntry_DoNotUse& other);
  static const SpireConfig_ReplicasEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SpireConfig_ReplicasEntry_DoNotUse*>(&_SpireConfig_ReplicasEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "SpireConfig.ReplicasEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[5];
  }

  public:
};

// -------------------------------------------------------------------

class SpireConfig :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireConfig) */ {
 public:
  SpireConfig();
  virtual ~SpireConfig();

  SpireConfig(const SpireConfig& from);
  SpireConfig(SpireConfig&& from) noexcept
    : SpireConfig() {
    *this = ::std::move(from);
  }

  inline SpireConfig& operator=(const SpireConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireConfig& operator=(SpireConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireConfig* internal_default_instance() {
    return reinterpret_cast<const SpireConfig*>(
               &_SpireConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SpireConfig& a, SpireConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireConfig* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireConfig* New() const final {
    return CreateMaybeMessage<SpireConfig>(nullptr);
  }

  SpireConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireConfig& from);
  void MergeFrom(const SpireConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireConfig";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  typedef SpireConfig_Framework Framework;
  static constexpr Framework TENSORFLOW =
    SpireConfig_Framework_TENSORFLOW;
  static constexpr Framework PYTORCH =
    SpireConfig_Framework_PYTORCH;
  static inline bool Framework_IsValid(int value) {
    return SpireConfig_Framework_IsValid(value);
  }
  static constexpr Framework Framework_MIN =
    SpireConfig_Framework_Framework_MIN;
  static constexpr Framework Framework_MAX =
    SpireConfig_Framework_Framework_MAX;
  static constexpr int Framework_ARRAYSIZE =
    SpireConfig_Framework_Framework_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Framework_descriptor() {
    return SpireConfig_Framework_descriptor();
  }
  template<typename T>
  static inline const std::string& Framework_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Framework>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Framework_Name.");
    return SpireConfig_Framework_Name(enum_t_value);
  }
  static inline bool Framework_Parse(const std::string& name,
      Framework* value) {
    return SpireConfig_Framework_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEmbeddingLayerNamesFieldNumber = 11,
    kHeadsFieldNumber = 13,
    kLoadCheckpointScopesFieldNumber = 17,
    kCpuResourcesFieldNumber = 23,
    kReplicasFieldNumber = 24,
    kLandmarkPointsFieldNumber = 29,
    kNameFieldNumber = 1,
    kExpTypeFieldNumber = 3,
    kDatasetFieldNumber = 4,
    kDeviceTypeFieldNumber = 7,
    kDetectionLayerNameFieldNumber = 9,
    kUuidFieldNumber = 21,
    kEmbeddingsSpireConfFieldNumber = 25,
    kLandmarksSpireConfFieldNumber = 28,
    kFaceDetectFieldNumber = 14,
    kMetaFieldNumber = 15,
    kDataProviderParamsFieldNumber = 16,
    kEidFieldNumber = 2,
    kGpuMemoryFieldNumber = 5,
    kGpuBatchSizeFieldNumber = 6,
    kNumDevicesFieldNumber = 8,
    kDetectionScoreThresholdFieldNumber = 10,
    kTimestampMsFieldNumber = 18,
    kCompatibilityVersionIdFieldNumber = 20,
    kModelTypeFieldNumber = 19,
    kDenoiseVideoEmbeddingsFieldNumber = 30,
    kIsMultiheadedFieldNumber = 12,
    kSpatialReduceTypeFieldNumber = 22,
    kDetectionMaxBboxesFieldNumber = 26,
    kModelFrameworkFieldNumber = 27,
  };
  // repeated string embedding_layer_names = 11;
  int embedding_layer_names_size() const;
  void clear_embedding_layer_names();
  const std::string& embedding_layer_names(int index) const;
  std::string* mutable_embedding_layer_names(int index);
  void set_embedding_layer_names(int index, const std::string& value);
  void set_embedding_layer_names(int index, std::string&& value);
  void set_embedding_layer_names(int index, const char* value);
  void set_embedding_layer_names(int index, const char* value, size_t size);
  std::string* add_embedding_layer_names();
  void add_embedding_layer_names(const std::string& value);
  void add_embedding_layer_names(std::string&& value);
  void add_embedding_layer_names(const char* value);
  void add_embedding_layer_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& embedding_layer_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_embedding_layer_names();

  // map<string, .MultiHeadConfig> heads = 13;
  int heads_size() const;
  void clear_heads();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MultiHeadConfig >&
      heads() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MultiHeadConfig >*
      mutable_heads();

  // repeated .LoadCheckpointScope load_checkpoint_scopes = 17;
  int load_checkpoint_scopes_size() const;
  void clear_load_checkpoint_scopes();
  ::LoadCheckpointScope* mutable_load_checkpoint_scopes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LoadCheckpointScope >*
      mutable_load_checkpoint_scopes();
  const ::LoadCheckpointScope& load_checkpoint_scopes(int index) const;
  ::LoadCheckpointScope* add_load_checkpoint_scopes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LoadCheckpointScope >&
      load_checkpoint_scopes() const;

  // map<string, .CPUResources> cpu_resources = 23;
  int cpu_resources_size() const;
  void clear_cpu_resources();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CPUResources >&
      cpu_resources() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CPUResources >*
      mutable_cpu_resources();

  // map<string, .Replicas> replicas = 24;
  int replicas_size() const;
  void clear_replicas();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Replicas >&
      replicas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Replicas >*
      mutable_replicas();

  // repeated string landmark_points = 29;
  int landmark_points_size() const;
  void clear_landmark_points();
  const std::string& landmark_points(int index) const;
  std::string* mutable_landmark_points(int index);
  void set_landmark_points(int index, const std::string& value);
  void set_landmark_points(int index, std::string&& value);
  void set_landmark_points(int index, const char* value);
  void set_landmark_points(int index, const char* value, size_t size);
  std::string* add_landmark_points();
  void add_landmark_points(const std::string& value);
  void add_landmark_points(std::string&& value);
  void add_landmark_points(const char* value);
  void add_landmark_points(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& landmark_points() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_landmark_points();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string exp_type = 3 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_exp_type();
  PROTOBUF_DEPRECATED const std::string& exp_type() const;
  PROTOBUF_DEPRECATED void set_exp_type(const std::string& value);
  PROTOBUF_DEPRECATED void set_exp_type(std::string&& value);
  PROTOBUF_DEPRECATED void set_exp_type(const char* value);
  PROTOBUF_DEPRECATED void set_exp_type(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_exp_type();
  PROTOBUF_DEPRECATED std::string* release_exp_type();
  PROTOBUF_DEPRECATED void set_allocated_exp_type(std::string* exp_type);

  // string dataset = 4 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_dataset();
  PROTOBUF_DEPRECATED const std::string& dataset() const;
  PROTOBUF_DEPRECATED void set_dataset(const std::string& value);
  PROTOBUF_DEPRECATED void set_dataset(std::string&& value);
  PROTOBUF_DEPRECATED void set_dataset(const char* value);
  PROTOBUF_DEPRECATED void set_dataset(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_dataset();
  PROTOBUF_DEPRECATED std::string* release_dataset();
  PROTOBUF_DEPRECATED void set_allocated_dataset(std::string* dataset);

  // string device_type = 7;
  void clear_device_type();
  const std::string& device_type() const;
  void set_device_type(const std::string& value);
  void set_device_type(std::string&& value);
  void set_device_type(const char* value);
  void set_device_type(const char* value, size_t size);
  std::string* mutable_device_type();
  std::string* release_device_type();
  void set_allocated_device_type(std::string* device_type);

  // string detection_layer_name = 9;
  void clear_detection_layer_name();
  const std::string& detection_layer_name() const;
  void set_detection_layer_name(const std::string& value);
  void set_detection_layer_name(std::string&& value);
  void set_detection_layer_name(const char* value);
  void set_detection_layer_name(const char* value, size_t size);
  std::string* mutable_detection_layer_name();
  std::string* release_detection_layer_name();
  void set_allocated_detection_layer_name(std::string* detection_layer_name);

  // string uuid = 21;
  void clear_uuid();
  const std::string& uuid() const;
  void set_uuid(const std::string& value);
  void set_uuid(std::string&& value);
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  std::string* mutable_uuid();
  std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);

  // string embeddings_spire_conf = 25;
  void clear_embeddings_spire_conf();
  const std::string& embeddings_spire_conf() const;
  void set_embeddings_spire_conf(const std::string& value);
  void set_embeddings_spire_conf(std::string&& value);
  void set_embeddings_spire_conf(const char* value);
  void set_embeddings_spire_conf(const char* value, size_t size);
  std::string* mutable_embeddings_spire_conf();
  std::string* release_embeddings_spire_conf();
  void set_allocated_embeddings_spire_conf(std::string* embeddings_spire_conf);

  // string landmarks_spire_conf = 28;
  void clear_landmarks_spire_conf();
  const std::string& landmarks_spire_conf() const;
  void set_landmarks_spire_conf(const std::string& value);
  void set_landmarks_spire_conf(std::string&& value);
  void set_landmarks_spire_conf(const char* value);
  void set_landmarks_spire_conf(const char* value, size_t size);
  std::string* mutable_landmarks_spire_conf();
  std::string* release_landmarks_spire_conf();
  void set_allocated_landmarks_spire_conf(std::string* landmarks_spire_conf);

  // .FaceDetectConfig face_detect = 14;
  bool has_face_detect() const;
  void clear_face_detect();
  const ::FaceDetectConfig& face_detect() const;
  ::FaceDetectConfig* release_face_detect();
  ::FaceDetectConfig* mutable_face_detect();
  void set_allocated_face_detect(::FaceDetectConfig* face_detect);

  // .SpireMeta meta = 15;
  bool has_meta() const;
  void clear_meta();
  const ::SpireMeta& meta() const;
  ::SpireMeta* release_meta();
  ::SpireMeta* mutable_meta();
  void set_allocated_meta(::SpireMeta* meta);

  // .DataProviderParams data_provider_params = 16;
  bool has_data_provider_params() const;
  void clear_data_provider_params();
  const ::DataProviderParams& data_provider_params() const;
  ::DataProviderParams* release_data_provider_params();
  ::DataProviderParams* mutable_data_provider_params();
  void set_allocated_data_provider_params(::DataProviderParams* data_provider_params);

  // int64 eid = 2;
  void clear_eid();
  ::PROTOBUF_NAMESPACE_ID::int64 eid() const;
  void set_eid(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int64 gpu_memory = 5;
  void clear_gpu_memory();
  ::PROTOBUF_NAMESPACE_ID::int64 gpu_memory() const;
  void set_gpu_memory(::PROTOBUF_NAMESPACE_ID::int64 value);

  // int32 gpu_batch_size = 6;
  void clear_gpu_batch_size();
  ::PROTOBUF_NAMESPACE_ID::int32 gpu_batch_size() const;
  void set_gpu_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 num_devices = 8;
  void clear_num_devices();
  ::PROTOBUF_NAMESPACE_ID::int32 num_devices() const;
  void set_num_devices(::PROTOBUF_NAMESPACE_ID::int32 value);

  // float detection_score_threshold = 10;
  void clear_detection_score_threshold();
  float detection_score_threshold() const;
  void set_detection_score_threshold(float value);

  // float timestamp_ms = 18;
  void clear_timestamp_ms();
  float timestamp_ms() const;
  void set_timestamp_ms(float value);

  // int64 compatibility_version_id = 20;
  void clear_compatibility_version_id();
  ::PROTOBUF_NAMESPACE_ID::int64 compatibility_version_id() const;
  void set_compatibility_version_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // .SpireModelType model_type = 19;
  void clear_model_type();
  ::SpireModelType model_type() const;
  void set_model_type(::SpireModelType value);

  // bool denoise_video_embeddings = 30;
  void clear_denoise_video_embeddings();
  bool denoise_video_embeddings() const;
  void set_denoise_video_embeddings(bool value);

  // bool is_multiheaded = 12;
  void clear_is_multiheaded();
  bool is_multiheaded() const;
  void set_is_multiheaded(bool value);

  // .SpireSpatialReduceType spatial_reduce_type = 22;
  void clear_spatial_reduce_type();
  ::SpireSpatialReduceType spatial_reduce_type() const;
  void set_spatial_reduce_type(::SpireSpatialReduceType value);

  // int32 detection_max_bboxes = 26;
  void clear_detection_max_bboxes();
  ::PROTOBUF_NAMESPACE_ID::int32 detection_max_bboxes() const;
  void set_detection_max_bboxes(::PROTOBUF_NAMESPACE_ID::int32 value);

  // .SpireConfig.Framework model_framework = 27;
  void clear_model_framework();
  ::SpireConfig_Framework model_framework() const;
  void set_model_framework(::SpireConfig_Framework value);

  // @@protoc_insertion_point(class_scope:SpireConfig)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> embedding_layer_names_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SpireConfig_HeadsEntry_DoNotUse,
      std::string, ::MultiHeadConfig,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > heads_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LoadCheckpointScope > load_checkpoint_scopes_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SpireConfig_CpuResourcesEntry_DoNotUse,
      std::string, ::CPUResources,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > cpu_resources_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SpireConfig_ReplicasEntry_DoNotUse,
      std::string, ::Replicas,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > replicas_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> landmark_points_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exp_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dataset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detection_layer_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr embeddings_spire_conf_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr landmarks_spire_conf_;
  ::FaceDetectConfig* face_detect_;
  ::SpireMeta* meta_;
  ::DataProviderParams* data_provider_params_;
  ::PROTOBUF_NAMESPACE_ID::int64 eid_;
  ::PROTOBUF_NAMESPACE_ID::int64 gpu_memory_;
  ::PROTOBUF_NAMESPACE_ID::int32 gpu_batch_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_devices_;
  float detection_score_threshold_;
  float timestamp_ms_;
  ::PROTOBUF_NAMESPACE_ID::int64 compatibility_version_id_;
  int model_type_;
  bool denoise_video_embeddings_;
  bool is_multiheaded_;
  int spatial_reduce_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 detection_max_bboxes_;
  int model_framework_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class Replicas :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Replicas) */ {
 public:
  Replicas();
  virtual ~Replicas();

  Replicas(const Replicas& from);
  Replicas(Replicas&& from) noexcept
    : Replicas() {
    *this = ::std::move(from);
  }

  inline Replicas& operator=(const Replicas& from) {
    CopyFrom(from);
    return *this;
  }
  inline Replicas& operator=(Replicas&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Replicas& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Replicas* internal_default_instance() {
    return reinterpret_cast<const Replicas*>(
               &_Replicas_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Replicas& a, Replicas& b) {
    a.Swap(&b);
  }
  inline void Swap(Replicas* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Replicas* New() const final {
    return CreateMaybeMessage<Replicas>(nullptr);
  }

  Replicas* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Replicas>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Replicas& from);
  void MergeFrom(const Replicas& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Replicas* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Replicas";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumFieldNumber = 1,
    kMaximumFieldNumber = 2,
  };
  // int32 minimum = 1;
  void clear_minimum();
  ::PROTOBUF_NAMESPACE_ID::int32 minimum() const;
  void set_minimum(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 maximum = 2;
  void clear_maximum();
  ::PROTOBUF_NAMESPACE_ID::int32 maximum() const;
  void set_maximum(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:Replicas)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 minimum_;
  ::PROTOBUF_NAMESPACE_ID::int32 maximum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class CPUResources :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CPUResources) */ {
 public:
  CPUResources();
  virtual ~CPUResources();

  CPUResources(const CPUResources& from);
  CPUResources(CPUResources&& from) noexcept
    : CPUResources() {
    *this = ::std::move(from);
  }

  inline CPUResources& operator=(const CPUResources& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPUResources& operator=(CPUResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CPUResources& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CPUResources* internal_default_instance() {
    return reinterpret_cast<const CPUResources*>(
               &_CPUResources_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CPUResources& a, CPUResources& b) {
    a.Swap(&b);
  }
  inline void Swap(CPUResources* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CPUResources* New() const final {
    return CreateMaybeMessage<CPUResources>(nullptr);
  }

  CPUResources* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CPUResources>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CPUResources& from);
  void MergeFrom(const CPUResources& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CPUResources* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CPUResources";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCpuCoreRequestFieldNumber = 1,
    kCpuCoreLimitFieldNumber = 2,
    kCpuMemRequestFieldNumber = 3,
    kCpuMemLimitFieldNumber = 4,
  };
  // string cpu_core_request = 1;
  void clear_cpu_core_request();
  const std::string& cpu_core_request() const;
  void set_cpu_core_request(const std::string& value);
  void set_cpu_core_request(std::string&& value);
  void set_cpu_core_request(const char* value);
  void set_cpu_core_request(const char* value, size_t size);
  std::string* mutable_cpu_core_request();
  std::string* release_cpu_core_request();
  void set_allocated_cpu_core_request(std::string* cpu_core_request);

  // string cpu_core_limit = 2;
  void clear_cpu_core_limit();
  const std::string& cpu_core_limit() const;
  void set_cpu_core_limit(const std::string& value);
  void set_cpu_core_limit(std::string&& value);
  void set_cpu_core_limit(const char* value);
  void set_cpu_core_limit(const char* value, size_t size);
  std::string* mutable_cpu_core_limit();
  std::string* release_cpu_core_limit();
  void set_allocated_cpu_core_limit(std::string* cpu_core_limit);

  // string cpu_mem_request = 3;
  void clear_cpu_mem_request();
  const std::string& cpu_mem_request() const;
  void set_cpu_mem_request(const std::string& value);
  void set_cpu_mem_request(std::string&& value);
  void set_cpu_mem_request(const char* value);
  void set_cpu_mem_request(const char* value, size_t size);
  std::string* mutable_cpu_mem_request();
  std::string* release_cpu_mem_request();
  void set_allocated_cpu_mem_request(std::string* cpu_mem_request);

  // string cpu_mem_limit = 4;
  void clear_cpu_mem_limit();
  const std::string& cpu_mem_limit() const;
  void set_cpu_mem_limit(const std::string& value);
  void set_cpu_mem_limit(std::string&& value);
  void set_cpu_mem_limit(const char* value);
  void set_cpu_mem_limit(const char* value, size_t size);
  std::string* mutable_cpu_mem_limit();
  std::string* release_cpu_mem_limit();
  void set_allocated_cpu_mem_limit(std::string* cpu_mem_limit);

  // @@protoc_insertion_point(class_scope:CPUResources)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cpu_core_request_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cpu_core_limit_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cpu_mem_request_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cpu_mem_limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireMeta :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireMeta) */ {
 public:
  SpireMeta();
  virtual ~SpireMeta();

  SpireMeta(const SpireMeta& from);
  SpireMeta(SpireMeta&& from) noexcept
    : SpireMeta() {
    *this = ::std::move(from);
  }

  inline SpireMeta& operator=(const SpireMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireMeta& operator=(SpireMeta&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireMeta& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireMeta* internal_default_instance() {
    return reinterpret_cast<const SpireMeta*>(
               &_SpireMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SpireMeta& a, SpireMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireMeta* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireMeta* New() const final {
    return CreateMaybeMessage<SpireMeta>(nullptr);
  }

  SpireMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireMeta>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireMeta& from);
  void MergeFrom(const SpireMeta& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireMeta* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireMeta";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 1,
    kLopqModelFieldNumber = 2,
  };
  // repeated string models = 1;
  int models_size() const;
  void clear_models();
  const std::string& models(int index) const;
  std::string* mutable_models(int index);
  void set_models(int index, const std::string& value);
  void set_models(int index, std::string&& value);
  void set_models(int index, const char* value);
  void set_models(int index, const char* value, size_t size);
  std::string* add_models();
  void add_models(const std::string& value);
  void add_models(std::string&& value);
  void add_models(const char* value);
  void add_models(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& models() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_models();

  // string lopq_model = 2;
  void clear_lopq_model();
  const std::string& lopq_model() const;
  void set_lopq_model(const std::string& value);
  void set_lopq_model(std::string&& value);
  void set_lopq_model(const char* value);
  void set_lopq_model(const char* value, size_t size);
  std::string* mutable_lopq_model();
  std::string* release_lopq_model();
  void set_allocated_lopq_model(std::string* lopq_model);

  // @@protoc_insertion_point(class_scope:SpireMeta)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> models_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lopq_model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireGetConfigRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireGetConfigRequest) */ {
 public:
  SpireGetConfigRequest();
  virtual ~SpireGetConfigRequest();

  SpireGetConfigRequest(const SpireGetConfigRequest& from);
  SpireGetConfigRequest(SpireGetConfigRequest&& from) noexcept
    : SpireGetConfigRequest() {
    *this = ::std::move(from);
  }

  inline SpireGetConfigRequest& operator=(const SpireGetConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireGetConfigRequest& operator=(SpireGetConfigRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireGetConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireGetConfigRequest* internal_default_instance() {
    return reinterpret_cast<const SpireGetConfigRequest*>(
               &_SpireGetConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SpireGetConfigRequest& a, SpireGetConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireGetConfigRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireGetConfigRequest* New() const final {
    return CreateMaybeMessage<SpireGetConfigRequest>(nullptr);
  }

  SpireGetConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireGetConfigRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireGetConfigRequest& from);
  void MergeFrom(const SpireGetConfigRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireGetConfigRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireGetConfigRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetaFieldNumber = 1,
    kUseLockFieldNumber = 2,
  };
  // .RequestMeta meta = 1;
  bool has_meta() const;
  void clear_meta();
  const ::RequestMeta& meta() const;
  ::RequestMeta* release_meta();
  ::RequestMeta* mutable_meta();
  void set_allocated_meta(::RequestMeta* meta);

  // bool use_lock = 2;
  void clear_use_lock();
  bool use_lock() const;
  void set_use_lock(bool value);

  // @@protoc_insertion_point(class_scope:SpireGetConfigRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::RequestMeta* meta_;
  bool use_lock_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireGetConfigResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireGetConfigResponse) */ {
 public:
  SpireGetConfigResponse();
  virtual ~SpireGetConfigResponse();

  SpireGetConfigResponse(const SpireGetConfigResponse& from);
  SpireGetConfigResponse(SpireGetConfigResponse&& from) noexcept
    : SpireGetConfigResponse() {
    *this = ::std::move(from);
  }

  inline SpireGetConfigResponse& operator=(const SpireGetConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireGetConfigResponse& operator=(SpireGetConfigResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireGetConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireGetConfigResponse* internal_default_instance() {
    return reinterpret_cast<const SpireGetConfigResponse*>(
               &_SpireGetConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SpireGetConfigResponse& a, SpireGetConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireGetConfigResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireGetConfigResponse* New() const final {
    return CreateMaybeMessage<SpireGetConfigResponse>(nullptr);
  }

  SpireGetConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireGetConfigResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireGetConfigResponse& from);
  void MergeFrom(const SpireGetConfigResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireGetConfigResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireGetConfigResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigJsonFieldNumber = 2,
    kStatusFieldNumber = 1,
    kConfigFieldNumber = 3,
  };
  // string config_json = 2;
  void clear_config_json();
  const std::string& config_json() const;
  void set_config_json(const std::string& value);
  void set_config_json(std::string&& value);
  void set_config_json(const char* value);
  void set_config_json(const char* value, size_t size);
  std::string* mutable_config_json();
  std::string* release_config_json();
  void set_allocated_config_json(std::string* config_json);

  // .ResponseStatus status = 1;
  bool has_status() const;
  void clear_status();
  const ::ResponseStatus& status() const;
  ::ResponseStatus* release_status();
  ::ResponseStatus* mutable_status();
  void set_allocated_status(::ResponseStatus* status);

  // .SpireConfig config = 3;
  bool has_config() const;
  void clear_config();
  const ::SpireConfig& config() const;
  ::SpireConfig* release_config();
  ::SpireConfig* mutable_config();
  void set_allocated_config(::SpireConfig* config);

  // @@protoc_insertion_point(class_scope:SpireGetConfigResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_json_;
  ::ResponseStatus* status_;
  ::SpireConfig* config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireSetConfigRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireSetConfigRequest) */ {
 public:
  SpireSetConfigRequest();
  virtual ~SpireSetConfigRequest();

  SpireSetConfigRequest(const SpireSetConfigRequest& from);
  SpireSetConfigRequest(SpireSetConfigRequest&& from) noexcept
    : SpireSetConfigRequest() {
    *this = ::std::move(from);
  }

  inline SpireSetConfigRequest& operator=(const SpireSetConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireSetConfigRequest& operator=(SpireSetConfigRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireSetConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireSetConfigRequest* internal_default_instance() {
    return reinterpret_cast<const SpireSetConfigRequest*>(
               &_SpireSetConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SpireSetConfigRequest& a, SpireSetConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireSetConfigRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireSetConfigRequest* New() const final {
    return CreateMaybeMessage<SpireSetConfigRequest>(nullptr);
  }

  SpireSetConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireSetConfigRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireSetConfigRequest& from);
  void MergeFrom(const SpireSetConfigRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireSetConfigRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireSetConfigRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigJsonFieldNumber = 2,
    kMetaFieldNumber = 1,
    kConfigFieldNumber = 3,
  };
  // string config_json = 2;
  void clear_config_json();
  const std::string& config_json() const;
  void set_config_json(const std::string& value);
  void set_config_json(std::string&& value);
  void set_config_json(const char* value);
  void set_config_json(const char* value, size_t size);
  std::string* mutable_config_json();
  std::string* release_config_json();
  void set_allocated_config_json(std::string* config_json);

  // .RequestMeta meta = 1;
  bool has_meta() const;
  void clear_meta();
  const ::RequestMeta& meta() const;
  ::RequestMeta* release_meta();
  ::RequestMeta* mutable_meta();
  void set_allocated_meta(::RequestMeta* meta);

  // .SpireConfig config = 3;
  bool has_config() const;
  void clear_config();
  const ::SpireConfig& config() const;
  ::SpireConfig* release_config();
  ::SpireConfig* mutable_config();
  void set_allocated_config(::SpireConfig* config);

  // @@protoc_insertion_point(class_scope:SpireSetConfigRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_json_;
  ::RequestMeta* meta_;
  ::SpireConfig* config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireSetConfigResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireSetConfigResponse) */ {
 public:
  SpireSetConfigResponse();
  virtual ~SpireSetConfigResponse();

  SpireSetConfigResponse(const SpireSetConfigResponse& from);
  SpireSetConfigResponse(SpireSetConfigResponse&& from) noexcept
    : SpireSetConfigResponse() {
    *this = ::std::move(from);
  }

  inline SpireSetConfigResponse& operator=(const SpireSetConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireSetConfigResponse& operator=(SpireSetConfigResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireSetConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireSetConfigResponse* internal_default_instance() {
    return reinterpret_cast<const SpireSetConfigResponse*>(
               &_SpireSetConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SpireSetConfigResponse& a, SpireSetConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireSetConfigResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireSetConfigResponse* New() const final {
    return CreateMaybeMessage<SpireSetConfigResponse>(nullptr);
  }

  SpireSetConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireSetConfigResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireSetConfigResponse& from);
  void MergeFrom(const SpireSetConfigResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireSetConfigResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireSetConfigResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .ResponseStatus status = 1;
  bool has_status() const;
  void clear_status();
  const ::ResponseStatus& status() const;
  ::ResponseStatus* release_status();
  ::ResponseStatus* mutable_status();
  void set_allocated_status(::ResponseStatus* status);

  // @@protoc_insertion_point(class_scope:SpireSetConfigResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::ResponseStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireGetStateRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireGetStateRequest) */ {
 public:
  SpireGetStateRequest();
  virtual ~SpireGetStateRequest();

  SpireGetStateRequest(const SpireGetStateRequest& from);
  SpireGetStateRequest(SpireGetStateRequest&& from) noexcept
    : SpireGetStateRequest() {
    *this = ::std::move(from);
  }

  inline SpireGetStateRequest& operator=(const SpireGetStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireGetStateRequest& operator=(SpireGetStateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireGetStateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireGetStateRequest* internal_default_instance() {
    return reinterpret_cast<const SpireGetStateRequest*>(
               &_SpireGetStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SpireGetStateRequest& a, SpireGetStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireGetStateRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireGetStateRequest* New() const final {
    return CreateMaybeMessage<SpireGetStateRequest>(nullptr);
  }

  SpireGetStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireGetStateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireGetStateRequest& from);
  void MergeFrom(const SpireGetStateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireGetStateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireGetStateRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetaFieldNumber = 1,
  };
  // .RequestMeta meta = 1;
  bool has_meta() const;
  void clear_meta();
  const ::RequestMeta& meta() const;
  ::RequestMeta* release_meta();
  ::RequestMeta* mutable_meta();
  void set_allocated_meta(::RequestMeta* meta);

  // @@protoc_insertion_point(class_scope:SpireGetStateRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::RequestMeta* meta_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireGetStateResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireGetStateResponse) */ {
 public:
  SpireGetStateResponse();
  virtual ~SpireGetStateResponse();

  SpireGetStateResponse(const SpireGetStateResponse& from);
  SpireGetStateResponse(SpireGetStateResponse&& from) noexcept
    : SpireGetStateResponse() {
    *this = ::std::move(from);
  }

  inline SpireGetStateResponse& operator=(const SpireGetStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireGetStateResponse& operator=(SpireGetStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireGetStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireGetStateResponse* internal_default_instance() {
    return reinterpret_cast<const SpireGetStateResponse*>(
               &_SpireGetStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SpireGetStateResponse& a, SpireGetStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireGetStateResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireGetStateResponse* New() const final {
    return CreateMaybeMessage<SpireGetStateResponse>(nullptr);
  }

  SpireGetStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireGetStateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireGetStateResponse& from);
  void MergeFrom(const SpireGetStateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireGetStateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireGetStateResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kLastInferenceTimeFieldNumber = 3,
    kStateFieldNumber = 2,
  };
  // .ResponseStatus status = 1;
  bool has_status() const;
  void clear_status();
  const ::ResponseStatus& status() const;
  ::ResponseStatus* release_status();
  ::ResponseStatus* mutable_status();
  void set_allocated_status(::ResponseStatus* status);

  // .google.protobuf.Timestamp last_inference_time = 3;
  bool has_last_inference_time() const;
  void clear_last_inference_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& last_inference_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_last_inference_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_inference_time();
  void set_allocated_last_inference_time(PROTOBUF_NAMESPACE_ID::Timestamp* last_inference_time);

  // .SpireState state = 2;
  void clear_state();
  ::SpireState state() const;
  void set_state(::SpireState value);

  // @@protoc_insertion_point(class_scope:SpireGetStateResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::ResponseStatus* status_;
  PROTOBUF_NAMESPACE_ID::Timestamp* last_inference_time_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireMaybeJITRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireMaybeJITRequest) */ {
 public:
  SpireMaybeJITRequest();
  virtual ~SpireMaybeJITRequest();

  SpireMaybeJITRequest(const SpireMaybeJITRequest& from);
  SpireMaybeJITRequest(SpireMaybeJITRequest&& from) noexcept
    : SpireMaybeJITRequest() {
    *this = ::std::move(from);
  }

  inline SpireMaybeJITRequest& operator=(const SpireMaybeJITRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireMaybeJITRequest& operator=(SpireMaybeJITRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireMaybeJITRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireMaybeJITRequest* internal_default_instance() {
    return reinterpret_cast<const SpireMaybeJITRequest*>(
               &_SpireMaybeJITRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SpireMaybeJITRequest& a, SpireMaybeJITRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireMaybeJITRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireMaybeJITRequest* New() const final {
    return CreateMaybeMessage<SpireMaybeJITRequest>(nullptr);
  }

  SpireMaybeJITRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireMaybeJITRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireMaybeJITRequest& from);
  void MergeFrom(const SpireMaybeJITRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireMaybeJITRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireMaybeJITRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetaFieldNumber = 1,
  };
  // .RequestMeta meta = 1;
  bool has_meta() const;
  void clear_meta();
  const ::RequestMeta& meta() const;
  ::RequestMeta* release_meta();
  ::RequestMeta* mutable_meta();
  void set_allocated_meta(::RequestMeta* meta);

  // @@protoc_insertion_point(class_scope:SpireMaybeJITRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::RequestMeta* meta_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireMaybeJITResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireMaybeJITResponse) */ {
 public:
  SpireMaybeJITResponse();
  virtual ~SpireMaybeJITResponse();

  SpireMaybeJITResponse(const SpireMaybeJITResponse& from);
  SpireMaybeJITResponse(SpireMaybeJITResponse&& from) noexcept
    : SpireMaybeJITResponse() {
    *this = ::std::move(from);
  }

  inline SpireMaybeJITResponse& operator=(const SpireMaybeJITResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireMaybeJITResponse& operator=(SpireMaybeJITResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireMaybeJITResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireMaybeJITResponse* internal_default_instance() {
    return reinterpret_cast<const SpireMaybeJITResponse*>(
               &_SpireMaybeJITResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SpireMaybeJITResponse& a, SpireMaybeJITResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireMaybeJITResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireMaybeJITResponse* New() const final {
    return CreateMaybeMessage<SpireMaybeJITResponse>(nullptr);
  }

  SpireMaybeJITResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireMaybeJITResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireMaybeJITResponse& from);
  void MergeFrom(const SpireMaybeJITResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireMaybeJITResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireMaybeJITResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .ResponseStatus status = 1;
  bool has_status() const;
  void clear_status();
  const ::ResponseStatus& status() const;
  ::ResponseStatus* release_status();
  ::ResponseStatus* mutable_status();
  void set_allocated_status(::ResponseStatus* status);

  // .SpireState state = 2;
  void clear_state();
  ::SpireState state() const;
  void set_state(::SpireState value);

  // @@protoc_insertion_point(class_scope:SpireMaybeJITResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::ResponseStatus* status_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireStopServingRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireStopServingRequest) */ {
 public:
  SpireStopServingRequest();
  virtual ~SpireStopServingRequest();

  SpireStopServingRequest(const SpireStopServingRequest& from);
  SpireStopServingRequest(SpireStopServingRequest&& from) noexcept
    : SpireStopServingRequest() {
    *this = ::std::move(from);
  }

  inline SpireStopServingRequest& operator=(const SpireStopServingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireStopServingRequest& operator=(SpireStopServingRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireStopServingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireStopServingRequest* internal_default_instance() {
    return reinterpret_cast<const SpireStopServingRequest*>(
               &_SpireStopServingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SpireStopServingRequest& a, SpireStopServingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireStopServingRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireStopServingRequest* New() const final {
    return CreateMaybeMessage<SpireStopServingRequest>(nullptr);
  }

  SpireStopServingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireStopServingRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireStopServingRequest& from);
  void MergeFrom(const SpireStopServingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireStopServingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireStopServingRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetaFieldNumber = 1,
  };
  // .RequestMeta meta = 1;
  bool has_meta() const;
  void clear_meta();
  const ::RequestMeta& meta() const;
  ::RequestMeta* release_meta();
  ::RequestMeta* mutable_meta();
  void set_allocated_meta(::RequestMeta* meta);

  // @@protoc_insertion_point(class_scope:SpireStopServingRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::RequestMeta* meta_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireStopServingResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireStopServingResponse) */ {
 public:
  SpireStopServingResponse();
  virtual ~SpireStopServingResponse();

  SpireStopServingResponse(const SpireStopServingResponse& from);
  SpireStopServingResponse(SpireStopServingResponse&& from) noexcept
    : SpireStopServingResponse() {
    *this = ::std::move(from);
  }

  inline SpireStopServingResponse& operator=(const SpireStopServingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireStopServingResponse& operator=(SpireStopServingResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireStopServingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireStopServingResponse* internal_default_instance() {
    return reinterpret_cast<const SpireStopServingResponse*>(
               &_SpireStopServingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SpireStopServingResponse& a, SpireStopServingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireStopServingResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireStopServingResponse* New() const final {
    return CreateMaybeMessage<SpireStopServingResponse>(nullptr);
  }

  SpireStopServingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireStopServingResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireStopServingResponse& from);
  void MergeFrom(const SpireStopServingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireStopServingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireStopServingResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .ResponseStatus status = 1;
  bool has_status() const;
  void clear_status();
  const ::ResponseStatus& status() const;
  ::ResponseStatus* release_status();
  ::ResponseStatus* mutable_status();
  void set_allocated_status(::ResponseStatus* status);

  // .SpireState state = 2;
  void clear_state();
  ::SpireState state() const;
  void set_state(::SpireState value);

  // @@protoc_insertion_point(class_scope:SpireStopServingResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::ResponseStatus* status_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireEmbedTagRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireEmbedTagRequest) */ {
 public:
  SpireEmbedTagRequest();
  virtual ~SpireEmbedTagRequest();

  SpireEmbedTagRequest(const SpireEmbedTagRequest& from);
  SpireEmbedTagRequest(SpireEmbedTagRequest&& from) noexcept
    : SpireEmbedTagRequest() {
    *this = ::std::move(from);
  }

  inline SpireEmbedTagRequest& operator=(const SpireEmbedTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireEmbedTagRequest& operator=(SpireEmbedTagRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireEmbedTagRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireEmbedTagRequest* internal_default_instance() {
    return reinterpret_cast<const SpireEmbedTagRequest*>(
               &_SpireEmbedTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SpireEmbedTagRequest& a, SpireEmbedTagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireEmbedTagRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireEmbedTagRequest* New() const final {
    return CreateMaybeMessage<SpireEmbedTagRequest>(nullptr);
  }

  SpireEmbedTagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireEmbedTagRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireEmbedTagRequest& from);
  void MergeFrom(const SpireEmbedTagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireEmbedTagRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireEmbedTagRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpsFieldNumber = 3,
    kTagsToWatchFieldNumber = 6,
    kLanguageFieldNumber = 7,
    kMetaFieldNumber = 1,
    kDataFieldNumber = 2,
    kTopkFieldNumber = 4,
    kFpsFieldNumber = 5,
  };
  // repeated .SpireOps ops = 3;
  int ops_size() const;
  void clear_ops();
  ::SpireOps ops(int index) const;
  void set_ops(int index, ::SpireOps value);
  void add_ops(::SpireOps value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ops() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_ops();

  // repeated .Tag tags_to_watch = 6;
  int tags_to_watch_size() const;
  void clear_tags_to_watch();
  ::Tag* mutable_tags_to_watch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag >*
      mutable_tags_to_watch();
  const ::Tag& tags_to_watch(int index) const;
  ::Tag* add_tags_to_watch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag >&
      tags_to_watch() const;

  // string language = 7 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_language();
  PROTOBUF_DEPRECATED const std::string& language() const;
  PROTOBUF_DEPRECATED void set_language(const std::string& value);
  PROTOBUF_DEPRECATED void set_language(std::string&& value);
  PROTOBUF_DEPRECATED void set_language(const char* value);
  PROTOBUF_DEPRECATED void set_language(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_language();
  PROTOBUF_DEPRECATED std::string* release_language();
  PROTOBUF_DEPRECATED void set_allocated_language(std::string* language);

  // .RequestMeta meta = 1;
  bool has_meta() const;
  void clear_meta();
  const ::RequestMeta& meta() const;
  ::RequestMeta* release_meta();
  ::RequestMeta* mutable_meta();
  void set_allocated_meta(::RequestMeta* meta);

  // .DataBatch data = 2;
  bool has_data() const;
  void clear_data();
  const ::DataBatch& data() const;
  ::DataBatch* release_data();
  ::DataBatch* mutable_data();
  void set_allocated_data(::DataBatch* data);

  // int32 topk = 4;
  void clear_topk();
  ::PROTOBUF_NAMESPACE_ID::int32 topk() const;
  void set_topk(::PROTOBUF_NAMESPACE_ID::int32 value);

  // float fps = 5;
  void clear_fps();
  float fps() const;
  void set_fps(float value);

  // @@protoc_insertion_point(class_scope:SpireEmbedTagRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> ops_;
  mutable std::atomic<int> _ops_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag > tags_to_watch_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::RequestMeta* meta_;
  ::DataBatch* data_;
  ::PROTOBUF_NAMESPACE_ID::int32 topk_;
  float fps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireEmbedTagResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireEmbedTagResponse) */ {
 public:
  SpireEmbedTagResponse();
  virtual ~SpireEmbedTagResponse();

  SpireEmbedTagResponse(const SpireEmbedTagResponse& from);
  SpireEmbedTagResponse(SpireEmbedTagResponse&& from) noexcept
    : SpireEmbedTagResponse() {
    *this = ::std::move(from);
  }

  inline SpireEmbedTagResponse& operator=(const SpireEmbedTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireEmbedTagResponse& operator=(SpireEmbedTagResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireEmbedTagResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireEmbedTagResponse* internal_default_instance() {
    return reinterpret_cast<const SpireEmbedTagResponse*>(
               &_SpireEmbedTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SpireEmbedTagResponse& a, SpireEmbedTagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireEmbedTagResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireEmbedTagResponse* New() const final {
    return CreateMaybeMessage<SpireEmbedTagResponse>(nullptr);
  }

  SpireEmbedTagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireEmbedTagResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireEmbedTagResponse& from);
  void MergeFrom(const SpireEmbedTagResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireEmbedTagResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireEmbedTagResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kResultsFieldNumber = 2,
  };
  // .ResponseStatus status = 1;
  bool has_status() const;
  void clear_status();
  const ::ResponseStatus& status() const;
  ::ResponseStatus* release_status();
  ::ResponseStatus* mutable_status();
  void set_allocated_status(::ResponseStatus* status);

  // .DataBatch results = 2;
  bool has_results() const;
  void clear_results();
  const ::DataBatch& results() const;
  ::DataBatch* release_results();
  ::DataBatch* mutable_results();
  void set_allocated_results(::DataBatch* results);

  // @@protoc_insertion_point(class_scope:SpireEmbedTagResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::ResponseStatus* status_;
  ::DataBatch* results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireSavedOutputRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireSavedOutputRequest) */ {
 public:
  SpireSavedOutputRequest();
  virtual ~SpireSavedOutputRequest();

  SpireSavedOutputRequest(const SpireSavedOutputRequest& from);
  SpireSavedOutputRequest(SpireSavedOutputRequest&& from) noexcept
    : SpireSavedOutputRequest() {
    *this = ::std::move(from);
  }

  inline SpireSavedOutputRequest& operator=(const SpireSavedOutputRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireSavedOutputRequest& operator=(SpireSavedOutputRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireSavedOutputRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireSavedOutputRequest* internal_default_instance() {
    return reinterpret_cast<const SpireSavedOutputRequest*>(
               &_SpireSavedOutputRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SpireSavedOutputRequest& a, SpireSavedOutputRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireSavedOutputRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireSavedOutputRequest* New() const final {
    return CreateMaybeMessage<SpireSavedOutputRequest>(nullptr);
  }

  SpireSavedOutputRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireSavedOutputRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireSavedOutputRequest& from);
  void MergeFrom(const SpireSavedOutputRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireSavedOutputRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireSavedOutputRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreLayersFieldNumber = 3,
    kMetaFieldNumber = 1,
    kDataFieldNumber = 2,
    kReduceNumViewsFieldNumber = 4,
    kReduceOutputSpaceFieldNumber = 5,
    kFpsFieldNumber = 6,
    kTopkFieldNumber = 7,
  };
  // repeated string store_layers = 3;
  int store_layers_size() const;
  void clear_store_layers();
  const std::string& store_layers(int index) const;
  std::string* mutable_store_layers(int index);
  void set_store_layers(int index, const std::string& value);
  void set_store_layers(int index, std::string&& value);
  void set_store_layers(int index, const char* value);
  void set_store_layers(int index, const char* value, size_t size);
  std::string* add_store_layers();
  void add_store_layers(const std::string& value);
  void add_store_layers(std::string&& value);
  void add_store_layers(const char* value);
  void add_store_layers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& store_layers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_store_layers();

  // .RequestMeta meta = 1;
  bool has_meta() const;
  void clear_meta();
  const ::RequestMeta& meta() const;
  ::RequestMeta* release_meta();
  ::RequestMeta* mutable_meta();
  void set_allocated_meta(::RequestMeta* meta);

  // .DataBatch data = 2;
  bool has_data() const;
  void clear_data();
  const ::DataBatch& data() const;
  ::DataBatch* release_data();
  ::DataBatch* mutable_data();
  void set_allocated_data(::DataBatch* data);

  // bool reduce_num_views = 4;
  void clear_reduce_num_views();
  bool reduce_num_views() const;
  void set_reduce_num_views(bool value);

  // bool reduce_output_space = 5;
  void clear_reduce_output_space();
  bool reduce_output_space() const;
  void set_reduce_output_space(bool value);

  // float fps = 6;
  void clear_fps();
  float fps() const;
  void set_fps(float value);

  // int32 topk = 7;
  void clear_topk();
  ::PROTOBUF_NAMESPACE_ID::int32 topk() const;
  void set_topk(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:SpireSavedOutputRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> store_layers_;
  ::RequestMeta* meta_;
  ::DataBatch* data_;
  bool reduce_num_views_;
  bool reduce_output_space_;
  float fps_;
  ::PROTOBUF_NAMESPACE_ID::int32 topk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireSavedOutputResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireSavedOutputResponse) */ {
 public:
  SpireSavedOutputResponse();
  virtual ~SpireSavedOutputResponse();

  SpireSavedOutputResponse(const SpireSavedOutputResponse& from);
  SpireSavedOutputResponse(SpireSavedOutputResponse&& from) noexcept
    : SpireSavedOutputResponse() {
    *this = ::std::move(from);
  }

  inline SpireSavedOutputResponse& operator=(const SpireSavedOutputResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireSavedOutputResponse& operator=(SpireSavedOutputResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireSavedOutputResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireSavedOutputResponse* internal_default_instance() {
    return reinterpret_cast<const SpireSavedOutputResponse*>(
               &_SpireSavedOutputResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SpireSavedOutputResponse& a, SpireSavedOutputResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireSavedOutputResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireSavedOutputResponse* New() const final {
    return CreateMaybeMessage<SpireSavedOutputResponse>(nullptr);
  }

  SpireSavedOutputResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireSavedOutputResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireSavedOutputResponse& from);
  void MergeFrom(const SpireSavedOutputResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireSavedOutputResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireSavedOutputResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kResultsFieldNumber = 2,
  };
  // .ResponseStatus status = 1;
  bool has_status() const;
  void clear_status();
  const ::ResponseStatus& status() const;
  ::ResponseStatus* release_status();
  ::ResponseStatus* mutable_status();
  void set_allocated_status(::ResponseStatus* status);

  // .DataBatch results = 2;
  bool has_results() const;
  void clear_results();
  const ::DataBatch& results() const;
  ::DataBatch* release_results();
  ::DataBatch* mutable_results();
  void set_allocated_results(::DataBatch* results);

  // @@protoc_insertion_point(class_scope:SpireSavedOutputResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::ResponseStatus* status_;
  ::DataBatch* results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireInstanceSegmentRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireInstanceSegmentRequest) */ {
 public:
  SpireInstanceSegmentRequest();
  virtual ~SpireInstanceSegmentRequest();

  SpireInstanceSegmentRequest(const SpireInstanceSegmentRequest& from);
  SpireInstanceSegmentRequest(SpireInstanceSegmentRequest&& from) noexcept
    : SpireInstanceSegmentRequest() {
    *this = ::std::move(from);
  }

  inline SpireInstanceSegmentRequest& operator=(const SpireInstanceSegmentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireInstanceSegmentRequest& operator=(SpireInstanceSegmentRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireInstanceSegmentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireInstanceSegmentRequest* internal_default_instance() {
    return reinterpret_cast<const SpireInstanceSegmentRequest*>(
               &_SpireInstanceSegmentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SpireInstanceSegmentRequest& a, SpireInstanceSegmentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireInstanceSegmentRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireInstanceSegmentRequest* New() const final {
    return CreateMaybeMessage<SpireInstanceSegmentRequest>(nullptr);
  }

  SpireInstanceSegmentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireInstanceSegmentRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireInstanceSegmentRequest& from);
  void MergeFrom(const SpireInstanceSegmentRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireInstanceSegmentRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireInstanceSegmentRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpsFieldNumber = 3,
    kTagsToWatchFieldNumber = 6,
    kMetaFieldNumber = 1,
    kDataFieldNumber = 2,
    kTopkFieldNumber = 4,
    kFpsFieldNumber = 5,
  };
  // repeated .SpireOps ops = 3;
  int ops_size() const;
  void clear_ops();
  ::SpireOps ops(int index) const;
  void set_ops(int index, ::SpireOps value);
  void add_ops(::SpireOps value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ops() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_ops();

  // repeated .Tag tags_to_watch = 6;
  int tags_to_watch_size() const;
  void clear_tags_to_watch();
  ::Tag* mutable_tags_to_watch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag >*
      mutable_tags_to_watch();
  const ::Tag& tags_to_watch(int index) const;
  ::Tag* add_tags_to_watch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag >&
      tags_to_watch() const;

  // .RequestMeta meta = 1;
  bool has_meta() const;
  void clear_meta();
  const ::RequestMeta& meta() const;
  ::RequestMeta* release_meta();
  ::RequestMeta* mutable_meta();
  void set_allocated_meta(::RequestMeta* meta);

  // .DataBatch data = 2;
  bool has_data() const;
  void clear_data();
  const ::DataBatch& data() const;
  ::DataBatch* release_data();
  ::DataBatch* mutable_data();
  void set_allocated_data(::DataBatch* data);

  // int32 topk = 4;
  void clear_topk();
  ::PROTOBUF_NAMESPACE_ID::int32 topk() const;
  void set_topk(::PROTOBUF_NAMESPACE_ID::int32 value);

  // float fps = 5;
  void clear_fps();
  float fps() const;
  void set_fps(float value);

  // @@protoc_insertion_point(class_scope:SpireInstanceSegmentRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> ops_;
  mutable std::atomic<int> _ops_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag > tags_to_watch_;
  ::RequestMeta* meta_;
  ::DataBatch* data_;
  ::PROTOBUF_NAMESPACE_ID::int32 topk_;
  float fps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireInstanceSegmentResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireInstanceSegmentResponse) */ {
 public:
  SpireInstanceSegmentResponse();
  virtual ~SpireInstanceSegmentResponse();

  SpireInstanceSegmentResponse(const SpireInstanceSegmentResponse& from);
  SpireInstanceSegmentResponse(SpireInstanceSegmentResponse&& from) noexcept
    : SpireInstanceSegmentResponse() {
    *this = ::std::move(from);
  }

  inline SpireInstanceSegmentResponse& operator=(const SpireInstanceSegmentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireInstanceSegmentResponse& operator=(SpireInstanceSegmentResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireInstanceSegmentResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireInstanceSegmentResponse* internal_default_instance() {
    return reinterpret_cast<const SpireInstanceSegmentResponse*>(
               &_SpireInstanceSegmentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SpireInstanceSegmentResponse& a, SpireInstanceSegmentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireInstanceSegmentResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireInstanceSegmentResponse* New() const final {
    return CreateMaybeMessage<SpireInstanceSegmentResponse>(nullptr);
  }

  SpireInstanceSegmentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireInstanceSegmentResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireInstanceSegmentResponse& from);
  void MergeFrom(const SpireInstanceSegmentResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireInstanceSegmentResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireInstanceSegmentResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kResultsFieldNumber = 2,
  };
  // .ResponseStatus status = 1;
  bool has_status() const;
  void clear_status();
  const ::ResponseStatus& status() const;
  ::ResponseStatus* release_status();
  ::ResponseStatus* mutable_status();
  void set_allocated_status(::ResponseStatus* status);

  // .DataBatch results = 2;
  bool has_results() const;
  void clear_results();
  const ::DataBatch& results() const;
  ::DataBatch* release_results();
  ::DataBatch* mutable_results();
  void set_allocated_results(::DataBatch* results);

  // @@protoc_insertion_point(class_scope:SpireInstanceSegmentResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::ResponseStatus* status_;
  ::DataBatch* results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireDetectEmbedTagRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireDetectEmbedTagRequest) */ {
 public:
  SpireDetectEmbedTagRequest();
  virtual ~SpireDetectEmbedTagRequest();

  SpireDetectEmbedTagRequest(const SpireDetectEmbedTagRequest& from);
  SpireDetectEmbedTagRequest(SpireDetectEmbedTagRequest&& from) noexcept
    : SpireDetectEmbedTagRequest() {
    *this = ::std::move(from);
  }

  inline SpireDetectEmbedTagRequest& operator=(const SpireDetectEmbedTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireDetectEmbedTagRequest& operator=(SpireDetectEmbedTagRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireDetectEmbedTagRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireDetectEmbedTagRequest* internal_default_instance() {
    return reinterpret_cast<const SpireDetectEmbedTagRequest*>(
               &_SpireDetectEmbedTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SpireDetectEmbedTagRequest& a, SpireDetectEmbedTagRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireDetectEmbedTagRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireDetectEmbedTagRequest* New() const final {
    return CreateMaybeMessage<SpireDetectEmbedTagRequest>(nullptr);
  }

  SpireDetectEmbedTagRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireDetectEmbedTagRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireDetectEmbedTagRequest& from);
  void MergeFrom(const SpireDetectEmbedTagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireDetectEmbedTagRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireDetectEmbedTagRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpsFieldNumber = 3,
    kTagsToWatchFieldNumber = 6,
    kMetaFieldNumber = 1,
    kDataFieldNumber = 2,
    kTopkFieldNumber = 4,
    kFpsFieldNumber = 5,
    kDetectionScoreThresholdFieldNumber = 7,
  };
  // repeated .SpireOps ops = 3;
  int ops_size() const;
  void clear_ops();
  ::SpireOps ops(int index) const;
  void set_ops(int index, ::SpireOps value);
  void add_ops(::SpireOps value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ops() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_ops();

  // repeated .Tag tags_to_watch = 6;
  int tags_to_watch_size() const;
  void clear_tags_to_watch();
  ::Tag* mutable_tags_to_watch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag >*
      mutable_tags_to_watch();
  const ::Tag& tags_to_watch(int index) const;
  ::Tag* add_tags_to_watch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag >&
      tags_to_watch() const;

  // .RequestMeta meta = 1;
  bool has_meta() const;
  void clear_meta();
  const ::RequestMeta& meta() const;
  ::RequestMeta* release_meta();
  ::RequestMeta* mutable_meta();
  void set_allocated_meta(::RequestMeta* meta);

  // .DataBatch data = 2;
  bool has_data() const;
  void clear_data();
  const ::DataBatch& data() const;
  ::DataBatch* release_data();
  ::DataBatch* mutable_data();
  void set_allocated_data(::DataBatch* data);

  // int32 topk = 4;
  void clear_topk();
  ::PROTOBUF_NAMESPACE_ID::int32 topk() const;
  void set_topk(::PROTOBUF_NAMESPACE_ID::int32 value);

  // float fps = 5;
  void clear_fps();
  float fps() const;
  void set_fps(float value);

  // float detection_score_threshold = 7;
  void clear_detection_score_threshold();
  float detection_score_threshold() const;
  void set_detection_score_threshold(float value);

  // @@protoc_insertion_point(class_scope:SpireDetectEmbedTagRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> ops_;
  mutable std::atomic<int> _ops_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag > tags_to_watch_;
  ::RequestMeta* meta_;
  ::DataBatch* data_;
  ::PROTOBUF_NAMESPACE_ID::int32 topk_;
  float fps_;
  float detection_score_threshold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// -------------------------------------------------------------------

class SpireDetectEmbedTagResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpireDetectEmbedTagResponse) */ {
 public:
  SpireDetectEmbedTagResponse();
  virtual ~SpireDetectEmbedTagResponse();

  SpireDetectEmbedTagResponse(const SpireDetectEmbedTagResponse& from);
  SpireDetectEmbedTagResponse(SpireDetectEmbedTagResponse&& from) noexcept
    : SpireDetectEmbedTagResponse() {
    *this = ::std::move(from);
  }

  inline SpireDetectEmbedTagResponse& operator=(const SpireDetectEmbedTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpireDetectEmbedTagResponse& operator=(SpireDetectEmbedTagResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpireDetectEmbedTagResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpireDetectEmbedTagResponse* internal_default_instance() {
    return reinterpret_cast<const SpireDetectEmbedTagResponse*>(
               &_SpireDetectEmbedTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SpireDetectEmbedTagResponse& a, SpireDetectEmbedTagResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SpireDetectEmbedTagResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpireDetectEmbedTagResponse* New() const final {
    return CreateMaybeMessage<SpireDetectEmbedTagResponse>(nullptr);
  }

  SpireDetectEmbedTagResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpireDetectEmbedTagResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpireDetectEmbedTagResponse& from);
  void MergeFrom(const SpireDetectEmbedTagResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpireDetectEmbedTagResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SpireDetectEmbedTagResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fspire_2fspire_2eproto);
    return ::descriptor_table_proto_2fspire_2fspire_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kResultsFieldNumber = 2,
  };
  // .ResponseStatus status = 1;
  bool has_status() const;
  void clear_status();
  const ::ResponseStatus& status() const;
  ::ResponseStatus* release_status();
  ::ResponseStatus* mutable_status();
  void set_allocated_status(::ResponseStatus* status);

  // .DataBatch results = 2;
  bool has_results() const;
  void clear_results();
  const ::DataBatch& results() const;
  ::DataBatch* release_results();
  ::DataBatch* mutable_results();
  void set_allocated_results(::DataBatch* results);

  // @@protoc_insertion_point(class_scope:SpireDetectEmbedTagResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::ResponseStatus* status_;
  ::DataBatch* results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fspire_2fspire_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FaceDetectConfig

// string type = 1;
inline void FaceDetectConfig::clear_type() {
  type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& FaceDetectConfig::type() const {
  // @@protoc_insertion_point(field_get:FaceDetectConfig.type)
  return type_.GetNoArena();
}
inline void FaceDetectConfig::set_type(const std::string& value) {
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FaceDetectConfig.type)
}
inline void FaceDetectConfig::set_type(std::string&& value) {
  
  type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FaceDetectConfig.type)
}
inline void FaceDetectConfig::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FaceDetectConfig.type)
}
inline void FaceDetectConfig::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FaceDetectConfig.type)
}
inline std::string* FaceDetectConfig::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:FaceDetectConfig.type)
  return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FaceDetectConfig::release_type() {
  // @@protoc_insertion_point(field_release:FaceDetectConfig.type)
  
  return type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FaceDetectConfig::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:FaceDetectConfig.type)
}

// string spire_config = 2;
inline void FaceDetectConfig::clear_spire_config() {
  spire_config_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& FaceDetectConfig::spire_config() const {
  // @@protoc_insertion_point(field_get:FaceDetectConfig.spire_config)
  return spire_config_.GetNoArena();
}
inline void FaceDetectConfig::set_spire_config(const std::string& value) {
  
  spire_config_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FaceDetectConfig.spire_config)
}
inline void FaceDetectConfig::set_spire_config(std::string&& value) {
  
  spire_config_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FaceDetectConfig.spire_config)
}
inline void FaceDetectConfig::set_spire_config(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  spire_config_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FaceDetectConfig.spire_config)
}
inline void FaceDetectConfig::set_spire_config(const char* value, size_t size) {
  
  spire_config_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FaceDetectConfig.spire_config)
}
inline std::string* FaceDetectConfig::mutable_spire_config() {
  
  // @@protoc_insertion_point(field_mutable:FaceDetectConfig.spire_config)
  return spire_config_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FaceDetectConfig::release_spire_config() {
  // @@protoc_insertion_point(field_release:FaceDetectConfig.spire_config)
  
  return spire_config_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FaceDetectConfig::set_allocated_spire_config(std::string* spire_config) {
  if (spire_config != nullptr) {
    
  } else {
    
  }
  spire_config_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), spire_config);
  // @@protoc_insertion_point(field_set_allocated:FaceDetectConfig.spire_config)
}

// float detect_threshold = 3;
inline void FaceDetectConfig::clear_detect_threshold() {
  detect_threshold_ = 0;
}
inline float FaceDetectConfig::detect_threshold() const {
  // @@protoc_insertion_point(field_get:FaceDetectConfig.detect_threshold)
  return detect_threshold_;
}
inline void FaceDetectConfig::set_detect_threshold(float value) {
  
  detect_threshold_ = value;
  // @@protoc_insertion_point(field_set:FaceDetectConfig.detect_threshold)
}

// string cascade_path = 4;
inline void FaceDetectConfig::clear_cascade_path() {
  cascade_path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& FaceDetectConfig::cascade_path() const {
  // @@protoc_insertion_point(field_get:FaceDetectConfig.cascade_path)
  return cascade_path_.GetNoArena();
}
inline void FaceDetectConfig::set_cascade_path(const std::string& value) {
  
  cascade_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FaceDetectConfig.cascade_path)
}
inline void FaceDetectConfig::set_cascade_path(std::string&& value) {
  
  cascade_path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FaceDetectConfig.cascade_path)
}
inline void FaceDetectConfig::set_cascade_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cascade_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FaceDetectConfig.cascade_path)
}
inline void FaceDetectConfig::set_cascade_path(const char* value, size_t size) {
  
  cascade_path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FaceDetectConfig.cascade_path)
}
inline std::string* FaceDetectConfig::mutable_cascade_path() {
  
  // @@protoc_insertion_point(field_mutable:FaceDetectConfig.cascade_path)
  return cascade_path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FaceDetectConfig::release_cascade_path() {
  // @@protoc_insertion_point(field_release:FaceDetectConfig.cascade_path)
  
  return cascade_path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FaceDetectConfig::set_allocated_cascade_path(std::string* cascade_path) {
  if (cascade_path != nullptr) {
    
  } else {
    
  }
  cascade_path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cascade_path);
  // @@protoc_insertion_point(field_set_allocated:FaceDetectConfig.cascade_path)
}

// float min_size = 5;
inline void FaceDetectConfig::clear_min_size() {
  min_size_ = 0;
}
inline float FaceDetectConfig::min_size() const {
  // @@protoc_insertion_point(field_get:FaceDetectConfig.min_size)
  return min_size_;
}
inline void FaceDetectConfig::set_min_size(float value) {
  
  min_size_ = value;
  // @@protoc_insertion_point(field_set:FaceDetectConfig.min_size)
}

// .BBoxCropConfig bbox_crop = 6;
inline bool FaceDetectConfig::has_bbox_crop() const {
  return this != internal_default_instance() && bbox_crop_ != nullptr;
}
inline void FaceDetectConfig::clear_bbox_crop() {
  if (GetArenaNoVirtual() == nullptr && bbox_crop_ != nullptr) {
    delete bbox_crop_;
  }
  bbox_crop_ = nullptr;
}
inline const ::BBoxCropConfig& FaceDetectConfig::bbox_crop() const {
  const ::BBoxCropConfig* p = bbox_crop_;
  // @@protoc_insertion_point(field_get:FaceDetectConfig.bbox_crop)
  return p != nullptr ? *p : *reinterpret_cast<const ::BBoxCropConfig*>(
      &::_BBoxCropConfig_default_instance_);
}
inline ::BBoxCropConfig* FaceDetectConfig::release_bbox_crop() {
  // @@protoc_insertion_point(field_release:FaceDetectConfig.bbox_crop)
  
  ::BBoxCropConfig* temp = bbox_crop_;
  bbox_crop_ = nullptr;
  return temp;
}
inline ::BBoxCropConfig* FaceDetectConfig::mutable_bbox_crop() {
  
  if (bbox_crop_ == nullptr) {
    auto* p = CreateMaybeMessage<::BBoxCropConfig>(GetArenaNoVirtual());
    bbox_crop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:FaceDetectConfig.bbox_crop)
  return bbox_crop_;
}
inline void FaceDetectConfig::set_allocated_bbox_crop(::BBoxCropConfig* bbox_crop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bbox_crop_;
  }
  if (bbox_crop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bbox_crop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bbox_crop, submessage_arena);
    }
    
  } else {
    
  }
  bbox_crop_ = bbox_crop;
  // @@protoc_insertion_point(field_set_allocated:FaceDetectConfig.bbox_crop)
}

// -------------------------------------------------------------------

// BBoxCropConfig

// string type = 1;
inline void BBoxCropConfig::clear_type() {
  type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& BBoxCropConfig::type() const {
  // @@protoc_insertion_point(field_get:BBoxCropConfig.type)
  return type_.GetNoArena();
}
inline void BBoxCropConfig::set_type(const std::string& value) {
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BBoxCropConfig.type)
}
inline void BBoxCropConfig::set_type(std::string&& value) {
  
  type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BBoxCropConfig.type)
}
inline void BBoxCropConfig::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BBoxCropConfig.type)
}
inline void BBoxCropConfig::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BBoxCropConfig.type)
}
inline std::string* BBoxCropConfig::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:BBoxCropConfig.type)
  return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BBoxCropConfig::release_type() {
  // @@protoc_insertion_point(field_release:BBoxCropConfig.type)
  
  return type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BBoxCropConfig::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:BBoxCropConfig.type)
}

// float margin = 2;
inline void BBoxCropConfig::clear_margin() {
  margin_ = 0;
}
inline float BBoxCropConfig::margin() const {
  // @@protoc_insertion_point(field_get:BBoxCropConfig.margin)
  return margin_;
}
inline void BBoxCropConfig::set_margin(float value) {
  
  margin_ = value;
  // @@protoc_insertion_point(field_set:BBoxCropConfig.margin)
}

// -------------------------------------------------------------------

// MultiHeadConfig

// string dataset = 1 [deprecated = true];
inline void MultiHeadConfig::clear_dataset() {
  dataset_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MultiHeadConfig::dataset() const {
  // @@protoc_insertion_point(field_get:MultiHeadConfig.dataset)
  return dataset_.GetNoArena();
}
inline void MultiHeadConfig::set_dataset(const std::string& value) {
  
  dataset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MultiHeadConfig.dataset)
}
inline void MultiHeadConfig::set_dataset(std::string&& value) {
  
  dataset_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MultiHeadConfig.dataset)
}
inline void MultiHeadConfig::set_dataset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  dataset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MultiHeadConfig.dataset)
}
inline void MultiHeadConfig::set_dataset(const char* value, size_t size) {
  
  dataset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MultiHeadConfig.dataset)
}
inline std::string* MultiHeadConfig::mutable_dataset() {
  
  // @@protoc_insertion_point(field_mutable:MultiHeadConfig.dataset)
  return dataset_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MultiHeadConfig::release_dataset() {
  // @@protoc_insertion_point(field_release:MultiHeadConfig.dataset)
  
  return dataset_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MultiHeadConfig::set_allocated_dataset(std::string* dataset) {
  if (dataset != nullptr) {
    
  } else {
    
  }
  dataset_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dataset);
  // @@protoc_insertion_point(field_set_allocated:MultiHeadConfig.dataset)
}

// string face_key = 2;
inline void MultiHeadConfig::clear_face_key() {
  face_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MultiHeadConfig::face_key() const {
  // @@protoc_insertion_point(field_get:MultiHeadConfig.face_key)
  return face_key_.GetNoArena();
}
inline void MultiHeadConfig::set_face_key(const std::string& value) {
  
  face_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MultiHeadConfig.face_key)
}
inline void MultiHeadConfig::set_face_key(std::string&& value) {
  
  face_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MultiHeadConfig.face_key)
}
inline void MultiHeadConfig::set_face_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  face_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MultiHeadConfig.face_key)
}
inline void MultiHeadConfig::set_face_key(const char* value, size_t size) {
  
  face_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MultiHeadConfig.face_key)
}
inline std::string* MultiHeadConfig::mutable_face_key() {
  
  // @@protoc_insertion_point(field_mutable:MultiHeadConfig.face_key)
  return face_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MultiHeadConfig::release_face_key() {
  // @@protoc_insertion_point(field_release:MultiHeadConfig.face_key)
  
  return face_key_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MultiHeadConfig::set_allocated_face_key(std::string* face_key) {
  if (face_key != nullptr) {
    
  } else {
    
  }
  face_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), face_key);
  // @@protoc_insertion_point(field_set_allocated:MultiHeadConfig.face_key)
}

// .Vocab vocab = 3;
inline bool MultiHeadConfig::has_vocab() const {
  return this != internal_default_instance() && vocab_ != nullptr;
}
inline const ::Vocab& MultiHeadConfig::vocab() const {
  const ::Vocab* p = vocab_;
  // @@protoc_insertion_point(field_get:MultiHeadConfig.vocab)
  return p != nullptr ? *p : *reinterpret_cast<const ::Vocab*>(
      &::_Vocab_default_instance_);
}
inline ::Vocab* MultiHeadConfig::release_vocab() {
  // @@protoc_insertion_point(field_release:MultiHeadConfig.vocab)
  
  ::Vocab* temp = vocab_;
  vocab_ = nullptr;
  return temp;
}
inline ::Vocab* MultiHeadConfig::mutable_vocab() {
  
  if (vocab_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vocab>(GetArenaNoVirtual());
    vocab_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MultiHeadConfig.vocab)
  return vocab_;
}
inline void MultiHeadConfig::set_allocated_vocab(::Vocab* vocab) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vocab_);
  }
  if (vocab) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vocab = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vocab, submessage_arena);
    }
    
  } else {
    
  }
  vocab_ = vocab;
  // @@protoc_insertion_point(field_set_allocated:MultiHeadConfig.vocab)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SpireConfig

// string name = 1;
inline void SpireConfig::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SpireConfig::name() const {
  // @@protoc_insertion_point(field_get:SpireConfig.name)
  return name_.GetNoArena();
}
inline void SpireConfig::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpireConfig.name)
}
inline void SpireConfig::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpireConfig.name)
}
inline void SpireConfig::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpireConfig.name)
}
inline void SpireConfig::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpireConfig.name)
}
inline std::string* SpireConfig::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:SpireConfig.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SpireConfig::release_name() {
  // @@protoc_insertion_point(field_release:SpireConfig.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SpireConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:SpireConfig.name)
}

// int64 eid = 2;
inline void SpireConfig::clear_eid() {
  eid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SpireConfig::eid() const {
  // @@protoc_insertion_point(field_get:SpireConfig.eid)
  return eid_;
}
inline void SpireConfig::set_eid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  eid_ = value;
  // @@protoc_insertion_point(field_set:SpireConfig.eid)
}

// string exp_type = 3 [deprecated = true];
inline void SpireConfig::clear_exp_type() {
  exp_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SpireConfig::exp_type() const {
  // @@protoc_insertion_point(field_get:SpireConfig.exp_type)
  return exp_type_.GetNoArena();
}
inline void SpireConfig::set_exp_type(const std::string& value) {
  
  exp_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpireConfig.exp_type)
}
inline void SpireConfig::set_exp_type(std::string&& value) {
  
  exp_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpireConfig.exp_type)
}
inline void SpireConfig::set_exp_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  exp_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpireConfig.exp_type)
}
inline void SpireConfig::set_exp_type(const char* value, size_t size) {
  
  exp_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpireConfig.exp_type)
}
inline std::string* SpireConfig::mutable_exp_type() {
  
  // @@protoc_insertion_point(field_mutable:SpireConfig.exp_type)
  return exp_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SpireConfig::release_exp_type() {
  // @@protoc_insertion_point(field_release:SpireConfig.exp_type)
  
  return exp_type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SpireConfig::set_allocated_exp_type(std::string* exp_type) {
  if (exp_type != nullptr) {
    
  } else {
    
  }
  exp_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exp_type);
  // @@protoc_insertion_point(field_set_allocated:SpireConfig.exp_type)
}

// string dataset = 4 [deprecated = true];
inline void SpireConfig::clear_dataset() {
  dataset_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SpireConfig::dataset() const {
  // @@protoc_insertion_point(field_get:SpireConfig.dataset)
  return dataset_.GetNoArena();
}
inline void SpireConfig::set_dataset(const std::string& value) {
  
  dataset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpireConfig.dataset)
}
inline void SpireConfig::set_dataset(std::string&& value) {
  
  dataset_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpireConfig.dataset)
}
inline void SpireConfig::set_dataset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  dataset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpireConfig.dataset)
}
inline void SpireConfig::set_dataset(const char* value, size_t size) {
  
  dataset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpireConfig.dataset)
}
inline std::string* SpireConfig::mutable_dataset() {
  
  // @@protoc_insertion_point(field_mutable:SpireConfig.dataset)
  return dataset_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SpireConfig::release_dataset() {
  // @@protoc_insertion_point(field_release:SpireConfig.dataset)
  
  return dataset_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SpireConfig::set_allocated_dataset(std::string* dataset) {
  if (dataset != nullptr) {
    
  } else {
    
  }
  dataset_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dataset);
  // @@protoc_insertion_point(field_set_allocated:SpireConfig.dataset)
}

// int64 gpu_memory = 5;
inline void SpireConfig::clear_gpu_memory() {
  gpu_memory_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SpireConfig::gpu_memory() const {
  // @@protoc_insertion_point(field_get:SpireConfig.gpu_memory)
  return gpu_memory_;
}
inline void SpireConfig::set_gpu_memory(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  gpu_memory_ = value;
  // @@protoc_insertion_point(field_set:SpireConfig.gpu_memory)
}

// int32 gpu_batch_size = 6;
inline void SpireConfig::clear_gpu_batch_size() {
  gpu_batch_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpireConfig::gpu_batch_size() const {
  // @@protoc_insertion_point(field_get:SpireConfig.gpu_batch_size)
  return gpu_batch_size_;
}
inline void SpireConfig::set_gpu_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gpu_batch_size_ = value;
  // @@protoc_insertion_point(field_set:SpireConfig.gpu_batch_size)
}

// string device_type = 7;
inline void SpireConfig::clear_device_type() {
  device_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SpireConfig::device_type() const {
  // @@protoc_insertion_point(field_get:SpireConfig.device_type)
  return device_type_.GetNoArena();
}
inline void SpireConfig::set_device_type(const std::string& value) {
  
  device_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpireConfig.device_type)
}
inline void SpireConfig::set_device_type(std::string&& value) {
  
  device_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpireConfig.device_type)
}
inline void SpireConfig::set_device_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  device_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpireConfig.device_type)
}
inline void SpireConfig::set_device_type(const char* value, size_t size) {
  
  device_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpireConfig.device_type)
}
inline std::string* SpireConfig::mutable_device_type() {
  
  // @@protoc_insertion_point(field_mutable:SpireConfig.device_type)
  return device_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SpireConfig::release_device_type() {
  // @@protoc_insertion_point(field_release:SpireConfig.device_type)
  
  return device_type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SpireConfig::set_allocated_device_type(std::string* device_type) {
  if (device_type != nullptr) {
    
  } else {
    
  }
  device_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_type);
  // @@protoc_insertion_point(field_set_allocated:SpireConfig.device_type)
}

// int32 num_devices = 8;
inline void SpireConfig::clear_num_devices() {
  num_devices_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpireConfig::num_devices() const {
  // @@protoc_insertion_point(field_get:SpireConfig.num_devices)
  return num_devices_;
}
inline void SpireConfig::set_num_devices(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  num_devices_ = value;
  // @@protoc_insertion_point(field_set:SpireConfig.num_devices)
}

// string detection_layer_name = 9;
inline void SpireConfig::clear_detection_layer_name() {
  detection_layer_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SpireConfig::detection_layer_name() const {
  // @@protoc_insertion_point(field_get:SpireConfig.detection_layer_name)
  return detection_layer_name_.GetNoArena();
}
inline void SpireConfig::set_detection_layer_name(const std::string& value) {
  
  detection_layer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpireConfig.detection_layer_name)
}
inline void SpireConfig::set_detection_layer_name(std::string&& value) {
  
  detection_layer_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpireConfig.detection_layer_name)
}
inline void SpireConfig::set_detection_layer_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  detection_layer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpireConfig.detection_layer_name)
}
inline void SpireConfig::set_detection_layer_name(const char* value, size_t size) {
  
  detection_layer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpireConfig.detection_layer_name)
}
inline std::string* SpireConfig::mutable_detection_layer_name() {
  
  // @@protoc_insertion_point(field_mutable:SpireConfig.detection_layer_name)
  return detection_layer_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SpireConfig::release_detection_layer_name() {
  // @@protoc_insertion_point(field_release:SpireConfig.detection_layer_name)
  
  return detection_layer_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SpireConfig::set_allocated_detection_layer_name(std::string* detection_layer_name) {
  if (detection_layer_name != nullptr) {
    
  } else {
    
  }
  detection_layer_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), detection_layer_name);
  // @@protoc_insertion_point(field_set_allocated:SpireConfig.detection_layer_name)
}

// float detection_score_threshold = 10;
inline void SpireConfig::clear_detection_score_threshold() {
  detection_score_threshold_ = 0;
}
inline float SpireConfig::detection_score_threshold() const {
  // @@protoc_insertion_point(field_get:SpireConfig.detection_score_threshold)
  return detection_score_threshold_;
}
inline void SpireConfig::set_detection_score_threshold(float value) {
  
  detection_score_threshold_ = value;
  // @@protoc_insertion_point(field_set:SpireConfig.detection_score_threshold)
}

// int32 detection_max_bboxes = 26;
inline void SpireConfig::clear_detection_max_bboxes() {
  detection_max_bboxes_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpireConfig::detection_max_bboxes() const {
  // @@protoc_insertion_point(field_get:SpireConfig.detection_max_bboxes)
  return detection_max_bboxes_;
}
inline void SpireConfig::set_detection_max_bboxes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  detection_max_bboxes_ = value;
  // @@protoc_insertion_point(field_set:SpireConfig.detection_max_bboxes)
}

// repeated string embedding_layer_names = 11;
inline int SpireConfig::embedding_layer_names_size() const {
  return embedding_layer_names_.size();
}
inline void SpireConfig::clear_embedding_layer_names() {
  embedding_layer_names_.Clear();
}
inline const std::string& SpireConfig::embedding_layer_names(int index) const {
  // @@protoc_insertion_point(field_get:SpireConfig.embedding_layer_names)
  return embedding_layer_names_.Get(index);
}
inline std::string* SpireConfig::mutable_embedding_layer_names(int index) {
  // @@protoc_insertion_point(field_mutable:SpireConfig.embedding_layer_names)
  return embedding_layer_names_.Mutable(index);
}
inline void SpireConfig::set_embedding_layer_names(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:SpireConfig.embedding_layer_names)
  embedding_layer_names_.Mutable(index)->assign(value);
}
inline void SpireConfig::set_embedding_layer_names(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:SpireConfig.embedding_layer_names)
  embedding_layer_names_.Mutable(index)->assign(std::move(value));
}
inline void SpireConfig::set_embedding_layer_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  embedding_layer_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SpireConfig.embedding_layer_names)
}
inline void SpireConfig::set_embedding_layer_names(int index, const char* value, size_t size) {
  embedding_layer_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SpireConfig.embedding_layer_names)
}
inline std::string* SpireConfig::add_embedding_layer_names() {
  // @@protoc_insertion_point(field_add_mutable:SpireConfig.embedding_layer_names)
  return embedding_layer_names_.Add();
}
inline void SpireConfig::add_embedding_layer_names(const std::string& value) {
  embedding_layer_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SpireConfig.embedding_layer_names)
}
inline void SpireConfig::add_embedding_layer_names(std::string&& value) {
  embedding_layer_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SpireConfig.embedding_layer_names)
}
inline void SpireConfig::add_embedding_layer_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  embedding_layer_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SpireConfig.embedding_layer_names)
}
inline void SpireConfig::add_embedding_layer_names(const char* value, size_t size) {
  embedding_layer_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SpireConfig.embedding_layer_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SpireConfig::embedding_layer_names() const {
  // @@protoc_insertion_point(field_list:SpireConfig.embedding_layer_names)
  return embedding_layer_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SpireConfig::mutable_embedding_layer_names() {
  // @@protoc_insertion_point(field_mutable_list:SpireConfig.embedding_layer_names)
  return &embedding_layer_names_;
}

// bool denoise_video_embeddings = 30;
inline void SpireConfig::clear_denoise_video_embeddings() {
  denoise_video_embeddings_ = false;
}
inline bool SpireConfig::denoise_video_embeddings() const {
  // @@protoc_insertion_point(field_get:SpireConfig.denoise_video_embeddings)
  return denoise_video_embeddings_;
}
inline void SpireConfig::set_denoise_video_embeddings(bool value) {
  
  denoise_video_embeddings_ = value;
  // @@protoc_insertion_point(field_set:SpireConfig.denoise_video_embeddings)
}

// bool is_multiheaded = 12;
inline void SpireConfig::clear_is_multiheaded() {
  is_multiheaded_ = false;
}
inline bool SpireConfig::is_multiheaded() const {
  // @@protoc_insertion_point(field_get:SpireConfig.is_multiheaded)
  return is_multiheaded_;
}
inline void SpireConfig::set_is_multiheaded(bool value) {
  
  is_multiheaded_ = value;
  // @@protoc_insertion_point(field_set:SpireConfig.is_multiheaded)
}

// map<string, .MultiHeadConfig> heads = 13;
inline int SpireConfig::heads_size() const {
  return heads_.size();
}
inline void SpireConfig::clear_heads() {
  heads_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MultiHeadConfig >&
SpireConfig::heads() const {
  // @@protoc_insertion_point(field_map:SpireConfig.heads)
  return heads_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MultiHeadConfig >*
SpireConfig::mutable_heads() {
  // @@protoc_insertion_point(field_mutable_map:SpireConfig.heads)
  return heads_.MutableMap();
}

// .FaceDetectConfig face_detect = 14;
inline bool SpireConfig::has_face_detect() const {
  return this != internal_default_instance() && face_detect_ != nullptr;
}
inline void SpireConfig::clear_face_detect() {
  if (GetArenaNoVirtual() == nullptr && face_detect_ != nullptr) {
    delete face_detect_;
  }
  face_detect_ = nullptr;
}
inline const ::FaceDetectConfig& SpireConfig::face_detect() const {
  const ::FaceDetectConfig* p = face_detect_;
  // @@protoc_insertion_point(field_get:SpireConfig.face_detect)
  return p != nullptr ? *p : *reinterpret_cast<const ::FaceDetectConfig*>(
      &::_FaceDetectConfig_default_instance_);
}
inline ::FaceDetectConfig* SpireConfig::release_face_detect() {
  // @@protoc_insertion_point(field_release:SpireConfig.face_detect)
  
  ::FaceDetectConfig* temp = face_detect_;
  face_detect_ = nullptr;
  return temp;
}
inline ::FaceDetectConfig* SpireConfig::mutable_face_detect() {
  
  if (face_detect_ == nullptr) {
    auto* p = CreateMaybeMessage<::FaceDetectConfig>(GetArenaNoVirtual());
    face_detect_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireConfig.face_detect)
  return face_detect_;
}
inline void SpireConfig::set_allocated_face_detect(::FaceDetectConfig* face_detect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete face_detect_;
  }
  if (face_detect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      face_detect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, face_detect, submessage_arena);
    }
    
  } else {
    
  }
  face_detect_ = face_detect;
  // @@protoc_insertion_point(field_set_allocated:SpireConfig.face_detect)
}

// .SpireMeta meta = 15;
inline bool SpireConfig::has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline void SpireConfig::clear_meta() {
  if (GetArenaNoVirtual() == nullptr && meta_ != nullptr) {
    delete meta_;
  }
  meta_ = nullptr;
}
inline const ::SpireMeta& SpireConfig::meta() const {
  const ::SpireMeta* p = meta_;
  // @@protoc_insertion_point(field_get:SpireConfig.meta)
  return p != nullptr ? *p : *reinterpret_cast<const ::SpireMeta*>(
      &::_SpireMeta_default_instance_);
}
inline ::SpireMeta* SpireConfig::release_meta() {
  // @@protoc_insertion_point(field_release:SpireConfig.meta)
  
  ::SpireMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::SpireMeta* SpireConfig::mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::SpireMeta>(GetArenaNoVirtual());
    meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireConfig.meta)
  return meta_;
}
inline void SpireConfig::set_allocated_meta(::SpireMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:SpireConfig.meta)
}

// .DataProviderParams data_provider_params = 16;
inline bool SpireConfig::has_data_provider_params() const {
  return this != internal_default_instance() && data_provider_params_ != nullptr;
}
inline const ::DataProviderParams& SpireConfig::data_provider_params() const {
  const ::DataProviderParams* p = data_provider_params_;
  // @@protoc_insertion_point(field_get:SpireConfig.data_provider_params)
  return p != nullptr ? *p : *reinterpret_cast<const ::DataProviderParams*>(
      &::_DataProviderParams_default_instance_);
}
inline ::DataProviderParams* SpireConfig::release_data_provider_params() {
  // @@protoc_insertion_point(field_release:SpireConfig.data_provider_params)
  
  ::DataProviderParams* temp = data_provider_params_;
  data_provider_params_ = nullptr;
  return temp;
}
inline ::DataProviderParams* SpireConfig::mutable_data_provider_params() {
  
  if (data_provider_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::DataProviderParams>(GetArenaNoVirtual());
    data_provider_params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireConfig.data_provider_params)
  return data_provider_params_;
}
inline void SpireConfig::set_allocated_data_provider_params(::DataProviderParams* data_provider_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_provider_params_);
  }
  if (data_provider_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      data_provider_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_provider_params, submessage_arena);
    }
    
  } else {
    
  }
  data_provider_params_ = data_provider_params;
  // @@protoc_insertion_point(field_set_allocated:SpireConfig.data_provider_params)
}

// repeated .LoadCheckpointScope load_checkpoint_scopes = 17;
inline int SpireConfig::load_checkpoint_scopes_size() const {
  return load_checkpoint_scopes_.size();
}
inline ::LoadCheckpointScope* SpireConfig::mutable_load_checkpoint_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:SpireConfig.load_checkpoint_scopes)
  return load_checkpoint_scopes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LoadCheckpointScope >*
SpireConfig::mutable_load_checkpoint_scopes() {
  // @@protoc_insertion_point(field_mutable_list:SpireConfig.load_checkpoint_scopes)
  return &load_checkpoint_scopes_;
}
inline const ::LoadCheckpointScope& SpireConfig::load_checkpoint_scopes(int index) const {
  // @@protoc_insertion_point(field_get:SpireConfig.load_checkpoint_scopes)
  return load_checkpoint_scopes_.Get(index);
}
inline ::LoadCheckpointScope* SpireConfig::add_load_checkpoint_scopes() {
  // @@protoc_insertion_point(field_add:SpireConfig.load_checkpoint_scopes)
  return load_checkpoint_scopes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LoadCheckpointScope >&
SpireConfig::load_checkpoint_scopes() const {
  // @@protoc_insertion_point(field_list:SpireConfig.load_checkpoint_scopes)
  return load_checkpoint_scopes_;
}

// float timestamp_ms = 18;
inline void SpireConfig::clear_timestamp_ms() {
  timestamp_ms_ = 0;
}
inline float SpireConfig::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:SpireConfig.timestamp_ms)
  return timestamp_ms_;
}
inline void SpireConfig::set_timestamp_ms(float value) {
  
  timestamp_ms_ = value;
  // @@protoc_insertion_point(field_set:SpireConfig.timestamp_ms)
}

// .SpireModelType model_type = 19;
inline void SpireConfig::clear_model_type() {
  model_type_ = 0;
}
inline ::SpireModelType SpireConfig::model_type() const {
  // @@protoc_insertion_point(field_get:SpireConfig.model_type)
  return static_cast< ::SpireModelType >(model_type_);
}
inline void SpireConfig::set_model_type(::SpireModelType value) {
  
  model_type_ = value;
  // @@protoc_insertion_point(field_set:SpireConfig.model_type)
}

// int64 compatibility_version_id = 20;
inline void SpireConfig::clear_compatibility_version_id() {
  compatibility_version_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SpireConfig::compatibility_version_id() const {
  // @@protoc_insertion_point(field_get:SpireConfig.compatibility_version_id)
  return compatibility_version_id_;
}
inline void SpireConfig::set_compatibility_version_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  compatibility_version_id_ = value;
  // @@protoc_insertion_point(field_set:SpireConfig.compatibility_version_id)
}

// string uuid = 21;
inline void SpireConfig::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SpireConfig::uuid() const {
  // @@protoc_insertion_point(field_get:SpireConfig.uuid)
  return uuid_.GetNoArena();
}
inline void SpireConfig::set_uuid(const std::string& value) {
  
  uuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpireConfig.uuid)
}
inline void SpireConfig::set_uuid(std::string&& value) {
  
  uuid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpireConfig.uuid)
}
inline void SpireConfig::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpireConfig.uuid)
}
inline void SpireConfig::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpireConfig.uuid)
}
inline std::string* SpireConfig::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:SpireConfig.uuid)
  return uuid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SpireConfig::release_uuid() {
  // @@protoc_insertion_point(field_release:SpireConfig.uuid)
  
  return uuid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SpireConfig::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:SpireConfig.uuid)
}

// .SpireSpatialReduceType spatial_reduce_type = 22;
inline void SpireConfig::clear_spatial_reduce_type() {
  spatial_reduce_type_ = 0;
}
inline ::SpireSpatialReduceType SpireConfig::spatial_reduce_type() const {
  // @@protoc_insertion_point(field_get:SpireConfig.spatial_reduce_type)
  return static_cast< ::SpireSpatialReduceType >(spatial_reduce_type_);
}
inline void SpireConfig::set_spatial_reduce_type(::SpireSpatialReduceType value) {
  
  spatial_reduce_type_ = value;
  // @@protoc_insertion_point(field_set:SpireConfig.spatial_reduce_type)
}

// map<string, .CPUResources> cpu_resources = 23;
inline int SpireConfig::cpu_resources_size() const {
  return cpu_resources_.size();
}
inline void SpireConfig::clear_cpu_resources() {
  cpu_resources_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CPUResources >&
SpireConfig::cpu_resources() const {
  // @@protoc_insertion_point(field_map:SpireConfig.cpu_resources)
  return cpu_resources_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::CPUResources >*
SpireConfig::mutable_cpu_resources() {
  // @@protoc_insertion_point(field_mutable_map:SpireConfig.cpu_resources)
  return cpu_resources_.MutableMap();
}

// map<string, .Replicas> replicas = 24;
inline int SpireConfig::replicas_size() const {
  return replicas_.size();
}
inline void SpireConfig::clear_replicas() {
  replicas_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Replicas >&
SpireConfig::replicas() const {
  // @@protoc_insertion_point(field_map:SpireConfig.replicas)
  return replicas_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Replicas >*
SpireConfig::mutable_replicas() {
  // @@protoc_insertion_point(field_mutable_map:SpireConfig.replicas)
  return replicas_.MutableMap();
}

// string embeddings_spire_conf = 25;
inline void SpireConfig::clear_embeddings_spire_conf() {
  embeddings_spire_conf_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SpireConfig::embeddings_spire_conf() const {
  // @@protoc_insertion_point(field_get:SpireConfig.embeddings_spire_conf)
  return embeddings_spire_conf_.GetNoArena();
}
inline void SpireConfig::set_embeddings_spire_conf(const std::string& value) {
  
  embeddings_spire_conf_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpireConfig.embeddings_spire_conf)
}
inline void SpireConfig::set_embeddings_spire_conf(std::string&& value) {
  
  embeddings_spire_conf_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpireConfig.embeddings_spire_conf)
}
inline void SpireConfig::set_embeddings_spire_conf(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  embeddings_spire_conf_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpireConfig.embeddings_spire_conf)
}
inline void SpireConfig::set_embeddings_spire_conf(const char* value, size_t size) {
  
  embeddings_spire_conf_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpireConfig.embeddings_spire_conf)
}
inline std::string* SpireConfig::mutable_embeddings_spire_conf() {
  
  // @@protoc_insertion_point(field_mutable:SpireConfig.embeddings_spire_conf)
  return embeddings_spire_conf_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SpireConfig::release_embeddings_spire_conf() {
  // @@protoc_insertion_point(field_release:SpireConfig.embeddings_spire_conf)
  
  return embeddings_spire_conf_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SpireConfig::set_allocated_embeddings_spire_conf(std::string* embeddings_spire_conf) {
  if (embeddings_spire_conf != nullptr) {
    
  } else {
    
  }
  embeddings_spire_conf_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), embeddings_spire_conf);
  // @@protoc_insertion_point(field_set_allocated:SpireConfig.embeddings_spire_conf)
}

// string landmarks_spire_conf = 28;
inline void SpireConfig::clear_landmarks_spire_conf() {
  landmarks_spire_conf_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SpireConfig::landmarks_spire_conf() const {
  // @@protoc_insertion_point(field_get:SpireConfig.landmarks_spire_conf)
  return landmarks_spire_conf_.GetNoArena();
}
inline void SpireConfig::set_landmarks_spire_conf(const std::string& value) {
  
  landmarks_spire_conf_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpireConfig.landmarks_spire_conf)
}
inline void SpireConfig::set_landmarks_spire_conf(std::string&& value) {
  
  landmarks_spire_conf_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpireConfig.landmarks_spire_conf)
}
inline void SpireConfig::set_landmarks_spire_conf(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  landmarks_spire_conf_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpireConfig.landmarks_spire_conf)
}
inline void SpireConfig::set_landmarks_spire_conf(const char* value, size_t size) {
  
  landmarks_spire_conf_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpireConfig.landmarks_spire_conf)
}
inline std::string* SpireConfig::mutable_landmarks_spire_conf() {
  
  // @@protoc_insertion_point(field_mutable:SpireConfig.landmarks_spire_conf)
  return landmarks_spire_conf_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SpireConfig::release_landmarks_spire_conf() {
  // @@protoc_insertion_point(field_release:SpireConfig.landmarks_spire_conf)
  
  return landmarks_spire_conf_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SpireConfig::set_allocated_landmarks_spire_conf(std::string* landmarks_spire_conf) {
  if (landmarks_spire_conf != nullptr) {
    
  } else {
    
  }
  landmarks_spire_conf_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), landmarks_spire_conf);
  // @@protoc_insertion_point(field_set_allocated:SpireConfig.landmarks_spire_conf)
}

// .SpireConfig.Framework model_framework = 27;
inline void SpireConfig::clear_model_framework() {
  model_framework_ = 0;
}
inline ::SpireConfig_Framework SpireConfig::model_framework() const {
  // @@protoc_insertion_point(field_get:SpireConfig.model_framework)
  return static_cast< ::SpireConfig_Framework >(model_framework_);
}
inline void SpireConfig::set_model_framework(::SpireConfig_Framework value) {
  
  model_framework_ = value;
  // @@protoc_insertion_point(field_set:SpireConfig.model_framework)
}

// repeated string landmark_points = 29;
inline int SpireConfig::landmark_points_size() const {
  return landmark_points_.size();
}
inline void SpireConfig::clear_landmark_points() {
  landmark_points_.Clear();
}
inline const std::string& SpireConfig::landmark_points(int index) const {
  // @@protoc_insertion_point(field_get:SpireConfig.landmark_points)
  return landmark_points_.Get(index);
}
inline std::string* SpireConfig::mutable_landmark_points(int index) {
  // @@protoc_insertion_point(field_mutable:SpireConfig.landmark_points)
  return landmark_points_.Mutable(index);
}
inline void SpireConfig::set_landmark_points(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:SpireConfig.landmark_points)
  landmark_points_.Mutable(index)->assign(value);
}
inline void SpireConfig::set_landmark_points(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:SpireConfig.landmark_points)
  landmark_points_.Mutable(index)->assign(std::move(value));
}
inline void SpireConfig::set_landmark_points(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  landmark_points_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SpireConfig.landmark_points)
}
inline void SpireConfig::set_landmark_points(int index, const char* value, size_t size) {
  landmark_points_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SpireConfig.landmark_points)
}
inline std::string* SpireConfig::add_landmark_points() {
  // @@protoc_insertion_point(field_add_mutable:SpireConfig.landmark_points)
  return landmark_points_.Add();
}
inline void SpireConfig::add_landmark_points(const std::string& value) {
  landmark_points_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SpireConfig.landmark_points)
}
inline void SpireConfig::add_landmark_points(std::string&& value) {
  landmark_points_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SpireConfig.landmark_points)
}
inline void SpireConfig::add_landmark_points(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  landmark_points_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SpireConfig.landmark_points)
}
inline void SpireConfig::add_landmark_points(const char* value, size_t size) {
  landmark_points_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SpireConfig.landmark_points)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SpireConfig::landmark_points() const {
  // @@protoc_insertion_point(field_list:SpireConfig.landmark_points)
  return landmark_points_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SpireConfig::mutable_landmark_points() {
  // @@protoc_insertion_point(field_mutable_list:SpireConfig.landmark_points)
  return &landmark_points_;
}

// -------------------------------------------------------------------

// Replicas

// int32 minimum = 1;
inline void Replicas::clear_minimum() {
  minimum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Replicas::minimum() const {
  // @@protoc_insertion_point(field_get:Replicas.minimum)
  return minimum_;
}
inline void Replicas::set_minimum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  minimum_ = value;
  // @@protoc_insertion_point(field_set:Replicas.minimum)
}

// int32 maximum = 2;
inline void Replicas::clear_maximum() {
  maximum_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Replicas::maximum() const {
  // @@protoc_insertion_point(field_get:Replicas.maximum)
  return maximum_;
}
inline void Replicas::set_maximum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  maximum_ = value;
  // @@protoc_insertion_point(field_set:Replicas.maximum)
}

// -------------------------------------------------------------------

// CPUResources

// string cpu_core_request = 1;
inline void CPUResources::clear_cpu_core_request() {
  cpu_core_request_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CPUResources::cpu_core_request() const {
  // @@protoc_insertion_point(field_get:CPUResources.cpu_core_request)
  return cpu_core_request_.GetNoArena();
}
inline void CPUResources::set_cpu_core_request(const std::string& value) {
  
  cpu_core_request_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CPUResources.cpu_core_request)
}
inline void CPUResources::set_cpu_core_request(std::string&& value) {
  
  cpu_core_request_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CPUResources.cpu_core_request)
}
inline void CPUResources::set_cpu_core_request(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cpu_core_request_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CPUResources.cpu_core_request)
}
inline void CPUResources::set_cpu_core_request(const char* value, size_t size) {
  
  cpu_core_request_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CPUResources.cpu_core_request)
}
inline std::string* CPUResources::mutable_cpu_core_request() {
  
  // @@protoc_insertion_point(field_mutable:CPUResources.cpu_core_request)
  return cpu_core_request_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CPUResources::release_cpu_core_request() {
  // @@protoc_insertion_point(field_release:CPUResources.cpu_core_request)
  
  return cpu_core_request_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CPUResources::set_allocated_cpu_core_request(std::string* cpu_core_request) {
  if (cpu_core_request != nullptr) {
    
  } else {
    
  }
  cpu_core_request_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cpu_core_request);
  // @@protoc_insertion_point(field_set_allocated:CPUResources.cpu_core_request)
}

// string cpu_core_limit = 2;
inline void CPUResources::clear_cpu_core_limit() {
  cpu_core_limit_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CPUResources::cpu_core_limit() const {
  // @@protoc_insertion_point(field_get:CPUResources.cpu_core_limit)
  return cpu_core_limit_.GetNoArena();
}
inline void CPUResources::set_cpu_core_limit(const std::string& value) {
  
  cpu_core_limit_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CPUResources.cpu_core_limit)
}
inline void CPUResources::set_cpu_core_limit(std::string&& value) {
  
  cpu_core_limit_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CPUResources.cpu_core_limit)
}
inline void CPUResources::set_cpu_core_limit(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cpu_core_limit_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CPUResources.cpu_core_limit)
}
inline void CPUResources::set_cpu_core_limit(const char* value, size_t size) {
  
  cpu_core_limit_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CPUResources.cpu_core_limit)
}
inline std::string* CPUResources::mutable_cpu_core_limit() {
  
  // @@protoc_insertion_point(field_mutable:CPUResources.cpu_core_limit)
  return cpu_core_limit_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CPUResources::release_cpu_core_limit() {
  // @@protoc_insertion_point(field_release:CPUResources.cpu_core_limit)
  
  return cpu_core_limit_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CPUResources::set_allocated_cpu_core_limit(std::string* cpu_core_limit) {
  if (cpu_core_limit != nullptr) {
    
  } else {
    
  }
  cpu_core_limit_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cpu_core_limit);
  // @@protoc_insertion_point(field_set_allocated:CPUResources.cpu_core_limit)
}

// string cpu_mem_request = 3;
inline void CPUResources::clear_cpu_mem_request() {
  cpu_mem_request_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CPUResources::cpu_mem_request() const {
  // @@protoc_insertion_point(field_get:CPUResources.cpu_mem_request)
  return cpu_mem_request_.GetNoArena();
}
inline void CPUResources::set_cpu_mem_request(const std::string& value) {
  
  cpu_mem_request_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CPUResources.cpu_mem_request)
}
inline void CPUResources::set_cpu_mem_request(std::string&& value) {
  
  cpu_mem_request_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CPUResources.cpu_mem_request)
}
inline void CPUResources::set_cpu_mem_request(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cpu_mem_request_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CPUResources.cpu_mem_request)
}
inline void CPUResources::set_cpu_mem_request(const char* value, size_t size) {
  
  cpu_mem_request_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CPUResources.cpu_mem_request)
}
inline std::string* CPUResources::mutable_cpu_mem_request() {
  
  // @@protoc_insertion_point(field_mutable:CPUResources.cpu_mem_request)
  return cpu_mem_request_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CPUResources::release_cpu_mem_request() {
  // @@protoc_insertion_point(field_release:CPUResources.cpu_mem_request)
  
  return cpu_mem_request_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CPUResources::set_allocated_cpu_mem_request(std::string* cpu_mem_request) {
  if (cpu_mem_request != nullptr) {
    
  } else {
    
  }
  cpu_mem_request_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cpu_mem_request);
  // @@protoc_insertion_point(field_set_allocated:CPUResources.cpu_mem_request)
}

// string cpu_mem_limit = 4;
inline void CPUResources::clear_cpu_mem_limit() {
  cpu_mem_limit_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CPUResources::cpu_mem_limit() const {
  // @@protoc_insertion_point(field_get:CPUResources.cpu_mem_limit)
  return cpu_mem_limit_.GetNoArena();
}
inline void CPUResources::set_cpu_mem_limit(const std::string& value) {
  
  cpu_mem_limit_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CPUResources.cpu_mem_limit)
}
inline void CPUResources::set_cpu_mem_limit(std::string&& value) {
  
  cpu_mem_limit_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CPUResources.cpu_mem_limit)
}
inline void CPUResources::set_cpu_mem_limit(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  cpu_mem_limit_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CPUResources.cpu_mem_limit)
}
inline void CPUResources::set_cpu_mem_limit(const char* value, size_t size) {
  
  cpu_mem_limit_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CPUResources.cpu_mem_limit)
}
inline std::string* CPUResources::mutable_cpu_mem_limit() {
  
  // @@protoc_insertion_point(field_mutable:CPUResources.cpu_mem_limit)
  return cpu_mem_limit_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CPUResources::release_cpu_mem_limit() {
  // @@protoc_insertion_point(field_release:CPUResources.cpu_mem_limit)
  
  return cpu_mem_limit_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CPUResources::set_allocated_cpu_mem_limit(std::string* cpu_mem_limit) {
  if (cpu_mem_limit != nullptr) {
    
  } else {
    
  }
  cpu_mem_limit_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cpu_mem_limit);
  // @@protoc_insertion_point(field_set_allocated:CPUResources.cpu_mem_limit)
}

// -------------------------------------------------------------------

// SpireMeta

// repeated string models = 1;
inline int SpireMeta::models_size() const {
  return models_.size();
}
inline void SpireMeta::clear_models() {
  models_.Clear();
}
inline const std::string& SpireMeta::models(int index) const {
  // @@protoc_insertion_point(field_get:SpireMeta.models)
  return models_.Get(index);
}
inline std::string* SpireMeta::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:SpireMeta.models)
  return models_.Mutable(index);
}
inline void SpireMeta::set_models(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:SpireMeta.models)
  models_.Mutable(index)->assign(value);
}
inline void SpireMeta::set_models(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:SpireMeta.models)
  models_.Mutable(index)->assign(std::move(value));
}
inline void SpireMeta::set_models(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  models_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SpireMeta.models)
}
inline void SpireMeta::set_models(int index, const char* value, size_t size) {
  models_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SpireMeta.models)
}
inline std::string* SpireMeta::add_models() {
  // @@protoc_insertion_point(field_add_mutable:SpireMeta.models)
  return models_.Add();
}
inline void SpireMeta::add_models(const std::string& value) {
  models_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SpireMeta.models)
}
inline void SpireMeta::add_models(std::string&& value) {
  models_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SpireMeta.models)
}
inline void SpireMeta::add_models(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  models_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SpireMeta.models)
}
inline void SpireMeta::add_models(const char* value, size_t size) {
  models_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SpireMeta.models)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SpireMeta::models() const {
  // @@protoc_insertion_point(field_list:SpireMeta.models)
  return models_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SpireMeta::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:SpireMeta.models)
  return &models_;
}

// string lopq_model = 2;
inline void SpireMeta::clear_lopq_model() {
  lopq_model_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SpireMeta::lopq_model() const {
  // @@protoc_insertion_point(field_get:SpireMeta.lopq_model)
  return lopq_model_.GetNoArena();
}
inline void SpireMeta::set_lopq_model(const std::string& value) {
  
  lopq_model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpireMeta.lopq_model)
}
inline void SpireMeta::set_lopq_model(std::string&& value) {
  
  lopq_model_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpireMeta.lopq_model)
}
inline void SpireMeta::set_lopq_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  lopq_model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpireMeta.lopq_model)
}
inline void SpireMeta::set_lopq_model(const char* value, size_t size) {
  
  lopq_model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpireMeta.lopq_model)
}
inline std::string* SpireMeta::mutable_lopq_model() {
  
  // @@protoc_insertion_point(field_mutable:SpireMeta.lopq_model)
  return lopq_model_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SpireMeta::release_lopq_model() {
  // @@protoc_insertion_point(field_release:SpireMeta.lopq_model)
  
  return lopq_model_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SpireMeta::set_allocated_lopq_model(std::string* lopq_model) {
  if (lopq_model != nullptr) {
    
  } else {
    
  }
  lopq_model_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lopq_model);
  // @@protoc_insertion_point(field_set_allocated:SpireMeta.lopq_model)
}

// -------------------------------------------------------------------

// SpireGetConfigRequest

// .RequestMeta meta = 1;
inline bool SpireGetConfigRequest::has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline const ::RequestMeta& SpireGetConfigRequest::meta() const {
  const ::RequestMeta* p = meta_;
  // @@protoc_insertion_point(field_get:SpireGetConfigRequest.meta)
  return p != nullptr ? *p : *reinterpret_cast<const ::RequestMeta*>(
      &::_RequestMeta_default_instance_);
}
inline ::RequestMeta* SpireGetConfigRequest::release_meta() {
  // @@protoc_insertion_point(field_release:SpireGetConfigRequest.meta)
  
  ::RequestMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::RequestMeta* SpireGetConfigRequest::mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::RequestMeta>(GetArenaNoVirtual());
    meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireGetConfigRequest.meta)
  return meta_;
}
inline void SpireGetConfigRequest::set_allocated_meta(::RequestMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:SpireGetConfigRequest.meta)
}

// bool use_lock = 2;
inline void SpireGetConfigRequest::clear_use_lock() {
  use_lock_ = false;
}
inline bool SpireGetConfigRequest::use_lock() const {
  // @@protoc_insertion_point(field_get:SpireGetConfigRequest.use_lock)
  return use_lock_;
}
inline void SpireGetConfigRequest::set_use_lock(bool value) {
  
  use_lock_ = value;
  // @@protoc_insertion_point(field_set:SpireGetConfigRequest.use_lock)
}

// -------------------------------------------------------------------

// SpireGetConfigResponse

// .ResponseStatus status = 1;
inline bool SpireGetConfigResponse::has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline const ::ResponseStatus& SpireGetConfigResponse::status() const {
  const ::ResponseStatus* p = status_;
  // @@protoc_insertion_point(field_get:SpireGetConfigResponse.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::ResponseStatus*>(
      &::_ResponseStatus_default_instance_);
}
inline ::ResponseStatus* SpireGetConfigResponse::release_status() {
  // @@protoc_insertion_point(field_release:SpireGetConfigResponse.status)
  
  ::ResponseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ResponseStatus* SpireGetConfigResponse::mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResponseStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireGetConfigResponse.status)
  return status_;
}
inline void SpireGetConfigResponse::set_allocated_status(::ResponseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:SpireGetConfigResponse.status)
}

// string config_json = 2;
inline void SpireGetConfigResponse::clear_config_json() {
  config_json_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SpireGetConfigResponse::config_json() const {
  // @@protoc_insertion_point(field_get:SpireGetConfigResponse.config_json)
  return config_json_.GetNoArena();
}
inline void SpireGetConfigResponse::set_config_json(const std::string& value) {
  
  config_json_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpireGetConfigResponse.config_json)
}
inline void SpireGetConfigResponse::set_config_json(std::string&& value) {
  
  config_json_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpireGetConfigResponse.config_json)
}
inline void SpireGetConfigResponse::set_config_json(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  config_json_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpireGetConfigResponse.config_json)
}
inline void SpireGetConfigResponse::set_config_json(const char* value, size_t size) {
  
  config_json_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpireGetConfigResponse.config_json)
}
inline std::string* SpireGetConfigResponse::mutable_config_json() {
  
  // @@protoc_insertion_point(field_mutable:SpireGetConfigResponse.config_json)
  return config_json_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SpireGetConfigResponse::release_config_json() {
  // @@protoc_insertion_point(field_release:SpireGetConfigResponse.config_json)
  
  return config_json_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SpireGetConfigResponse::set_allocated_config_json(std::string* config_json) {
  if (config_json != nullptr) {
    
  } else {
    
  }
  config_json_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), config_json);
  // @@protoc_insertion_point(field_set_allocated:SpireGetConfigResponse.config_json)
}

// .SpireConfig config = 3;
inline bool SpireGetConfigResponse::has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline void SpireGetConfigResponse::clear_config() {
  if (GetArenaNoVirtual() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::SpireConfig& SpireGetConfigResponse::config() const {
  const ::SpireConfig* p = config_;
  // @@protoc_insertion_point(field_get:SpireGetConfigResponse.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::SpireConfig*>(
      &::_SpireConfig_default_instance_);
}
inline ::SpireConfig* SpireGetConfigResponse::release_config() {
  // @@protoc_insertion_point(field_release:SpireGetConfigResponse.config)
  
  ::SpireConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::SpireConfig* SpireGetConfigResponse::mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::SpireConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireGetConfigResponse.config)
  return config_;
}
inline void SpireGetConfigResponse::set_allocated_config(::SpireConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:SpireGetConfigResponse.config)
}

// -------------------------------------------------------------------

// SpireSetConfigRequest

// .RequestMeta meta = 1;
inline bool SpireSetConfigRequest::has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline const ::RequestMeta& SpireSetConfigRequest::meta() const {
  const ::RequestMeta* p = meta_;
  // @@protoc_insertion_point(field_get:SpireSetConfigRequest.meta)
  return p != nullptr ? *p : *reinterpret_cast<const ::RequestMeta*>(
      &::_RequestMeta_default_instance_);
}
inline ::RequestMeta* SpireSetConfigRequest::release_meta() {
  // @@protoc_insertion_point(field_release:SpireSetConfigRequest.meta)
  
  ::RequestMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::RequestMeta* SpireSetConfigRequest::mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::RequestMeta>(GetArenaNoVirtual());
    meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireSetConfigRequest.meta)
  return meta_;
}
inline void SpireSetConfigRequest::set_allocated_meta(::RequestMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:SpireSetConfigRequest.meta)
}

// string config_json = 2;
inline void SpireSetConfigRequest::clear_config_json() {
  config_json_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SpireSetConfigRequest::config_json() const {
  // @@protoc_insertion_point(field_get:SpireSetConfigRequest.config_json)
  return config_json_.GetNoArena();
}
inline void SpireSetConfigRequest::set_config_json(const std::string& value) {
  
  config_json_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpireSetConfigRequest.config_json)
}
inline void SpireSetConfigRequest::set_config_json(std::string&& value) {
  
  config_json_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpireSetConfigRequest.config_json)
}
inline void SpireSetConfigRequest::set_config_json(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  config_json_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpireSetConfigRequest.config_json)
}
inline void SpireSetConfigRequest::set_config_json(const char* value, size_t size) {
  
  config_json_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpireSetConfigRequest.config_json)
}
inline std::string* SpireSetConfigRequest::mutable_config_json() {
  
  // @@protoc_insertion_point(field_mutable:SpireSetConfigRequest.config_json)
  return config_json_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SpireSetConfigRequest::release_config_json() {
  // @@protoc_insertion_point(field_release:SpireSetConfigRequest.config_json)
  
  return config_json_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SpireSetConfigRequest::set_allocated_config_json(std::string* config_json) {
  if (config_json != nullptr) {
    
  } else {
    
  }
  config_json_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), config_json);
  // @@protoc_insertion_point(field_set_allocated:SpireSetConfigRequest.config_json)
}

// .SpireConfig config = 3;
inline bool SpireSetConfigRequest::has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline void SpireSetConfigRequest::clear_config() {
  if (GetArenaNoVirtual() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::SpireConfig& SpireSetConfigRequest::config() const {
  const ::SpireConfig* p = config_;
  // @@protoc_insertion_point(field_get:SpireSetConfigRequest.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::SpireConfig*>(
      &::_SpireConfig_default_instance_);
}
inline ::SpireConfig* SpireSetConfigRequest::release_config() {
  // @@protoc_insertion_point(field_release:SpireSetConfigRequest.config)
  
  ::SpireConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::SpireConfig* SpireSetConfigRequest::mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::SpireConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireSetConfigRequest.config)
  return config_;
}
inline void SpireSetConfigRequest::set_allocated_config(::SpireConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:SpireSetConfigRequest.config)
}

// -------------------------------------------------------------------

// SpireSetConfigResponse

// .ResponseStatus status = 1;
inline bool SpireSetConfigResponse::has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline const ::ResponseStatus& SpireSetConfigResponse::status() const {
  const ::ResponseStatus* p = status_;
  // @@protoc_insertion_point(field_get:SpireSetConfigResponse.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::ResponseStatus*>(
      &::_ResponseStatus_default_instance_);
}
inline ::ResponseStatus* SpireSetConfigResponse::release_status() {
  // @@protoc_insertion_point(field_release:SpireSetConfigResponse.status)
  
  ::ResponseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ResponseStatus* SpireSetConfigResponse::mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResponseStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireSetConfigResponse.status)
  return status_;
}
inline void SpireSetConfigResponse::set_allocated_status(::ResponseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:SpireSetConfigResponse.status)
}

// -------------------------------------------------------------------

// SpireGetStateRequest

// .RequestMeta meta = 1;
inline bool SpireGetStateRequest::has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline const ::RequestMeta& SpireGetStateRequest::meta() const {
  const ::RequestMeta* p = meta_;
  // @@protoc_insertion_point(field_get:SpireGetStateRequest.meta)
  return p != nullptr ? *p : *reinterpret_cast<const ::RequestMeta*>(
      &::_RequestMeta_default_instance_);
}
inline ::RequestMeta* SpireGetStateRequest::release_meta() {
  // @@protoc_insertion_point(field_release:SpireGetStateRequest.meta)
  
  ::RequestMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::RequestMeta* SpireGetStateRequest::mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::RequestMeta>(GetArenaNoVirtual());
    meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireGetStateRequest.meta)
  return meta_;
}
inline void SpireGetStateRequest::set_allocated_meta(::RequestMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:SpireGetStateRequest.meta)
}

// -------------------------------------------------------------------

// SpireGetStateResponse

// .ResponseStatus status = 1;
inline bool SpireGetStateResponse::has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline const ::ResponseStatus& SpireGetStateResponse::status() const {
  const ::ResponseStatus* p = status_;
  // @@protoc_insertion_point(field_get:SpireGetStateResponse.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::ResponseStatus*>(
      &::_ResponseStatus_default_instance_);
}
inline ::ResponseStatus* SpireGetStateResponse::release_status() {
  // @@protoc_insertion_point(field_release:SpireGetStateResponse.status)
  
  ::ResponseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ResponseStatus* SpireGetStateResponse::mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResponseStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireGetStateResponse.status)
  return status_;
}
inline void SpireGetStateResponse::set_allocated_status(::ResponseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:SpireGetStateResponse.status)
}

// .SpireState state = 2;
inline void SpireGetStateResponse::clear_state() {
  state_ = 0;
}
inline ::SpireState SpireGetStateResponse::state() const {
  // @@protoc_insertion_point(field_get:SpireGetStateResponse.state)
  return static_cast< ::SpireState >(state_);
}
inline void SpireGetStateResponse::set_state(::SpireState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:SpireGetStateResponse.state)
}

// .google.protobuf.Timestamp last_inference_time = 3;
inline bool SpireGetStateResponse::has_last_inference_time() const {
  return this != internal_default_instance() && last_inference_time_ != nullptr;
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& SpireGetStateResponse::last_inference_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = last_inference_time_;
  // @@protoc_insertion_point(field_get:SpireGetStateResponse.last_inference_time)
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* SpireGetStateResponse::release_last_inference_time() {
  // @@protoc_insertion_point(field_release:SpireGetStateResponse.last_inference_time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_inference_time_;
  last_inference_time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* SpireGetStateResponse::mutable_last_inference_time() {
  
  if (last_inference_time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaNoVirtual());
    last_inference_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireGetStateResponse.last_inference_time)
  return last_inference_time_;
}
inline void SpireGetStateResponse::set_allocated_last_inference_time(PROTOBUF_NAMESPACE_ID::Timestamp* last_inference_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_inference_time_);
  }
  if (last_inference_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_inference_time)->GetArena();
    if (message_arena != submessage_arena) {
      last_inference_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_inference_time, submessage_arena);
    }
    
  } else {
    
  }
  last_inference_time_ = last_inference_time;
  // @@protoc_insertion_point(field_set_allocated:SpireGetStateResponse.last_inference_time)
}

// -------------------------------------------------------------------

// SpireMaybeJITRequest

// .RequestMeta meta = 1;
inline bool SpireMaybeJITRequest::has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline const ::RequestMeta& SpireMaybeJITRequest::meta() const {
  const ::RequestMeta* p = meta_;
  // @@protoc_insertion_point(field_get:SpireMaybeJITRequest.meta)
  return p != nullptr ? *p : *reinterpret_cast<const ::RequestMeta*>(
      &::_RequestMeta_default_instance_);
}
inline ::RequestMeta* SpireMaybeJITRequest::release_meta() {
  // @@protoc_insertion_point(field_release:SpireMaybeJITRequest.meta)
  
  ::RequestMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::RequestMeta* SpireMaybeJITRequest::mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::RequestMeta>(GetArenaNoVirtual());
    meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireMaybeJITRequest.meta)
  return meta_;
}
inline void SpireMaybeJITRequest::set_allocated_meta(::RequestMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:SpireMaybeJITRequest.meta)
}

// -------------------------------------------------------------------

// SpireMaybeJITResponse

// .ResponseStatus status = 1;
inline bool SpireMaybeJITResponse::has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline const ::ResponseStatus& SpireMaybeJITResponse::status() const {
  const ::ResponseStatus* p = status_;
  // @@protoc_insertion_point(field_get:SpireMaybeJITResponse.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::ResponseStatus*>(
      &::_ResponseStatus_default_instance_);
}
inline ::ResponseStatus* SpireMaybeJITResponse::release_status() {
  // @@protoc_insertion_point(field_release:SpireMaybeJITResponse.status)
  
  ::ResponseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ResponseStatus* SpireMaybeJITResponse::mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResponseStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireMaybeJITResponse.status)
  return status_;
}
inline void SpireMaybeJITResponse::set_allocated_status(::ResponseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:SpireMaybeJITResponse.status)
}

// .SpireState state = 2;
inline void SpireMaybeJITResponse::clear_state() {
  state_ = 0;
}
inline ::SpireState SpireMaybeJITResponse::state() const {
  // @@protoc_insertion_point(field_get:SpireMaybeJITResponse.state)
  return static_cast< ::SpireState >(state_);
}
inline void SpireMaybeJITResponse::set_state(::SpireState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:SpireMaybeJITResponse.state)
}

// -------------------------------------------------------------------

// SpireStopServingRequest

// .RequestMeta meta = 1;
inline bool SpireStopServingRequest::has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline const ::RequestMeta& SpireStopServingRequest::meta() const {
  const ::RequestMeta* p = meta_;
  // @@protoc_insertion_point(field_get:SpireStopServingRequest.meta)
  return p != nullptr ? *p : *reinterpret_cast<const ::RequestMeta*>(
      &::_RequestMeta_default_instance_);
}
inline ::RequestMeta* SpireStopServingRequest::release_meta() {
  // @@protoc_insertion_point(field_release:SpireStopServingRequest.meta)
  
  ::RequestMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::RequestMeta* SpireStopServingRequest::mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::RequestMeta>(GetArenaNoVirtual());
    meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireStopServingRequest.meta)
  return meta_;
}
inline void SpireStopServingRequest::set_allocated_meta(::RequestMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:SpireStopServingRequest.meta)
}

// -------------------------------------------------------------------

// SpireStopServingResponse

// .ResponseStatus status = 1;
inline bool SpireStopServingResponse::has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline const ::ResponseStatus& SpireStopServingResponse::status() const {
  const ::ResponseStatus* p = status_;
  // @@protoc_insertion_point(field_get:SpireStopServingResponse.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::ResponseStatus*>(
      &::_ResponseStatus_default_instance_);
}
inline ::ResponseStatus* SpireStopServingResponse::release_status() {
  // @@protoc_insertion_point(field_release:SpireStopServingResponse.status)
  
  ::ResponseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ResponseStatus* SpireStopServingResponse::mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResponseStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireStopServingResponse.status)
  return status_;
}
inline void SpireStopServingResponse::set_allocated_status(::ResponseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:SpireStopServingResponse.status)
}

// .SpireState state = 2;
inline void SpireStopServingResponse::clear_state() {
  state_ = 0;
}
inline ::SpireState SpireStopServingResponse::state() const {
  // @@protoc_insertion_point(field_get:SpireStopServingResponse.state)
  return static_cast< ::SpireState >(state_);
}
inline void SpireStopServingResponse::set_state(::SpireState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:SpireStopServingResponse.state)
}

// -------------------------------------------------------------------

// SpireEmbedTagRequest

// .RequestMeta meta = 1;
inline bool SpireEmbedTagRequest::has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline const ::RequestMeta& SpireEmbedTagRequest::meta() const {
  const ::RequestMeta* p = meta_;
  // @@protoc_insertion_point(field_get:SpireEmbedTagRequest.meta)
  return p != nullptr ? *p : *reinterpret_cast<const ::RequestMeta*>(
      &::_RequestMeta_default_instance_);
}
inline ::RequestMeta* SpireEmbedTagRequest::release_meta() {
  // @@protoc_insertion_point(field_release:SpireEmbedTagRequest.meta)
  
  ::RequestMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::RequestMeta* SpireEmbedTagRequest::mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::RequestMeta>(GetArenaNoVirtual());
    meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireEmbedTagRequest.meta)
  return meta_;
}
inline void SpireEmbedTagRequest::set_allocated_meta(::RequestMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:SpireEmbedTagRequest.meta)
}

// .DataBatch data = 2;
inline bool SpireEmbedTagRequest::has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline const ::DataBatch& SpireEmbedTagRequest::data() const {
  const ::DataBatch* p = data_;
  // @@protoc_insertion_point(field_get:SpireEmbedTagRequest.data)
  return p != nullptr ? *p : *reinterpret_cast<const ::DataBatch*>(
      &::_DataBatch_default_instance_);
}
inline ::DataBatch* SpireEmbedTagRequest::release_data() {
  // @@protoc_insertion_point(field_release:SpireEmbedTagRequest.data)
  
  ::DataBatch* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::DataBatch* SpireEmbedTagRequest::mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DataBatch>(GetArenaNoVirtual());
    data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireEmbedTagRequest.data)
  return data_;
}
inline void SpireEmbedTagRequest::set_allocated_data(::DataBatch* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:SpireEmbedTagRequest.data)
}

// repeated .SpireOps ops = 3;
inline int SpireEmbedTagRequest::ops_size() const {
  return ops_.size();
}
inline void SpireEmbedTagRequest::clear_ops() {
  ops_.Clear();
}
inline ::SpireOps SpireEmbedTagRequest::ops(int index) const {
  // @@protoc_insertion_point(field_get:SpireEmbedTagRequest.ops)
  return static_cast< ::SpireOps >(ops_.Get(index));
}
inline void SpireEmbedTagRequest::set_ops(int index, ::SpireOps value) {
  ops_.Set(index, value);
  // @@protoc_insertion_point(field_set:SpireEmbedTagRequest.ops)
}
inline void SpireEmbedTagRequest::add_ops(::SpireOps value) {
  ops_.Add(value);
  // @@protoc_insertion_point(field_add:SpireEmbedTagRequest.ops)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SpireEmbedTagRequest::ops() const {
  // @@protoc_insertion_point(field_list:SpireEmbedTagRequest.ops)
  return ops_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SpireEmbedTagRequest::mutable_ops() {
  // @@protoc_insertion_point(field_mutable_list:SpireEmbedTagRequest.ops)
  return &ops_;
}

// int32 topk = 4;
inline void SpireEmbedTagRequest::clear_topk() {
  topk_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpireEmbedTagRequest::topk() const {
  // @@protoc_insertion_point(field_get:SpireEmbedTagRequest.topk)
  return topk_;
}
inline void SpireEmbedTagRequest::set_topk(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  topk_ = value;
  // @@protoc_insertion_point(field_set:SpireEmbedTagRequest.topk)
}

// float fps = 5;
inline void SpireEmbedTagRequest::clear_fps() {
  fps_ = 0;
}
inline float SpireEmbedTagRequest::fps() const {
  // @@protoc_insertion_point(field_get:SpireEmbedTagRequest.fps)
  return fps_;
}
inline void SpireEmbedTagRequest::set_fps(float value) {
  
  fps_ = value;
  // @@protoc_insertion_point(field_set:SpireEmbedTagRequest.fps)
}

// repeated .Tag tags_to_watch = 6;
inline int SpireEmbedTagRequest::tags_to_watch_size() const {
  return tags_to_watch_.size();
}
inline ::Tag* SpireEmbedTagRequest::mutable_tags_to_watch(int index) {
  // @@protoc_insertion_point(field_mutable:SpireEmbedTagRequest.tags_to_watch)
  return tags_to_watch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag >*
SpireEmbedTagRequest::mutable_tags_to_watch() {
  // @@protoc_insertion_point(field_mutable_list:SpireEmbedTagRequest.tags_to_watch)
  return &tags_to_watch_;
}
inline const ::Tag& SpireEmbedTagRequest::tags_to_watch(int index) const {
  // @@protoc_insertion_point(field_get:SpireEmbedTagRequest.tags_to_watch)
  return tags_to_watch_.Get(index);
}
inline ::Tag* SpireEmbedTagRequest::add_tags_to_watch() {
  // @@protoc_insertion_point(field_add:SpireEmbedTagRequest.tags_to_watch)
  return tags_to_watch_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag >&
SpireEmbedTagRequest::tags_to_watch() const {
  // @@protoc_insertion_point(field_list:SpireEmbedTagRequest.tags_to_watch)
  return tags_to_watch_;
}

// string language = 7 [deprecated = true];
inline void SpireEmbedTagRequest::clear_language() {
  language_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SpireEmbedTagRequest::language() const {
  // @@protoc_insertion_point(field_get:SpireEmbedTagRequest.language)
  return language_.GetNoArena();
}
inline void SpireEmbedTagRequest::set_language(const std::string& value) {
  
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SpireEmbedTagRequest.language)
}
inline void SpireEmbedTagRequest::set_language(std::string&& value) {
  
  language_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SpireEmbedTagRequest.language)
}
inline void SpireEmbedTagRequest::set_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SpireEmbedTagRequest.language)
}
inline void SpireEmbedTagRequest::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SpireEmbedTagRequest.language)
}
inline std::string* SpireEmbedTagRequest::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:SpireEmbedTagRequest.language)
  return language_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SpireEmbedTagRequest::release_language() {
  // @@protoc_insertion_point(field_release:SpireEmbedTagRequest.language)
  
  return language_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SpireEmbedTagRequest::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:SpireEmbedTagRequest.language)
}

// -------------------------------------------------------------------

// SpireEmbedTagResponse

// .ResponseStatus status = 1;
inline bool SpireEmbedTagResponse::has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline const ::ResponseStatus& SpireEmbedTagResponse::status() const {
  const ::ResponseStatus* p = status_;
  // @@protoc_insertion_point(field_get:SpireEmbedTagResponse.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::ResponseStatus*>(
      &::_ResponseStatus_default_instance_);
}
inline ::ResponseStatus* SpireEmbedTagResponse::release_status() {
  // @@protoc_insertion_point(field_release:SpireEmbedTagResponse.status)
  
  ::ResponseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ResponseStatus* SpireEmbedTagResponse::mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResponseStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireEmbedTagResponse.status)
  return status_;
}
inline void SpireEmbedTagResponse::set_allocated_status(::ResponseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:SpireEmbedTagResponse.status)
}

// .DataBatch results = 2;
inline bool SpireEmbedTagResponse::has_results() const {
  return this != internal_default_instance() && results_ != nullptr;
}
inline const ::DataBatch& SpireEmbedTagResponse::results() const {
  const ::DataBatch* p = results_;
  // @@protoc_insertion_point(field_get:SpireEmbedTagResponse.results)
  return p != nullptr ? *p : *reinterpret_cast<const ::DataBatch*>(
      &::_DataBatch_default_instance_);
}
inline ::DataBatch* SpireEmbedTagResponse::release_results() {
  // @@protoc_insertion_point(field_release:SpireEmbedTagResponse.results)
  
  ::DataBatch* temp = results_;
  results_ = nullptr;
  return temp;
}
inline ::DataBatch* SpireEmbedTagResponse::mutable_results() {
  
  if (results_ == nullptr) {
    auto* p = CreateMaybeMessage<::DataBatch>(GetArenaNoVirtual());
    results_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireEmbedTagResponse.results)
  return results_;
}
inline void SpireEmbedTagResponse::set_allocated_results(::DataBatch* results) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(results_);
  }
  if (results) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      results = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, results, submessage_arena);
    }
    
  } else {
    
  }
  results_ = results;
  // @@protoc_insertion_point(field_set_allocated:SpireEmbedTagResponse.results)
}

// -------------------------------------------------------------------

// SpireSavedOutputRequest

// .RequestMeta meta = 1;
inline bool SpireSavedOutputRequest::has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline const ::RequestMeta& SpireSavedOutputRequest::meta() const {
  const ::RequestMeta* p = meta_;
  // @@protoc_insertion_point(field_get:SpireSavedOutputRequest.meta)
  return p != nullptr ? *p : *reinterpret_cast<const ::RequestMeta*>(
      &::_RequestMeta_default_instance_);
}
inline ::RequestMeta* SpireSavedOutputRequest::release_meta() {
  // @@protoc_insertion_point(field_release:SpireSavedOutputRequest.meta)
  
  ::RequestMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::RequestMeta* SpireSavedOutputRequest::mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::RequestMeta>(GetArenaNoVirtual());
    meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireSavedOutputRequest.meta)
  return meta_;
}
inline void SpireSavedOutputRequest::set_allocated_meta(::RequestMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:SpireSavedOutputRequest.meta)
}

// .DataBatch data = 2;
inline bool SpireSavedOutputRequest::has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline const ::DataBatch& SpireSavedOutputRequest::data() const {
  const ::DataBatch* p = data_;
  // @@protoc_insertion_point(field_get:SpireSavedOutputRequest.data)
  return p != nullptr ? *p : *reinterpret_cast<const ::DataBatch*>(
      &::_DataBatch_default_instance_);
}
inline ::DataBatch* SpireSavedOutputRequest::release_data() {
  // @@protoc_insertion_point(field_release:SpireSavedOutputRequest.data)
  
  ::DataBatch* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::DataBatch* SpireSavedOutputRequest::mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DataBatch>(GetArenaNoVirtual());
    data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireSavedOutputRequest.data)
  return data_;
}
inline void SpireSavedOutputRequest::set_allocated_data(::DataBatch* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:SpireSavedOutputRequest.data)
}

// repeated string store_layers = 3;
inline int SpireSavedOutputRequest::store_layers_size() const {
  return store_layers_.size();
}
inline void SpireSavedOutputRequest::clear_store_layers() {
  store_layers_.Clear();
}
inline const std::string& SpireSavedOutputRequest::store_layers(int index) const {
  // @@protoc_insertion_point(field_get:SpireSavedOutputRequest.store_layers)
  return store_layers_.Get(index);
}
inline std::string* SpireSavedOutputRequest::mutable_store_layers(int index) {
  // @@protoc_insertion_point(field_mutable:SpireSavedOutputRequest.store_layers)
  return store_layers_.Mutable(index);
}
inline void SpireSavedOutputRequest::set_store_layers(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:SpireSavedOutputRequest.store_layers)
  store_layers_.Mutable(index)->assign(value);
}
inline void SpireSavedOutputRequest::set_store_layers(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:SpireSavedOutputRequest.store_layers)
  store_layers_.Mutable(index)->assign(std::move(value));
}
inline void SpireSavedOutputRequest::set_store_layers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  store_layers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SpireSavedOutputRequest.store_layers)
}
inline void SpireSavedOutputRequest::set_store_layers(int index, const char* value, size_t size) {
  store_layers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SpireSavedOutputRequest.store_layers)
}
inline std::string* SpireSavedOutputRequest::add_store_layers() {
  // @@protoc_insertion_point(field_add_mutable:SpireSavedOutputRequest.store_layers)
  return store_layers_.Add();
}
inline void SpireSavedOutputRequest::add_store_layers(const std::string& value) {
  store_layers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SpireSavedOutputRequest.store_layers)
}
inline void SpireSavedOutputRequest::add_store_layers(std::string&& value) {
  store_layers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SpireSavedOutputRequest.store_layers)
}
inline void SpireSavedOutputRequest::add_store_layers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  store_layers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SpireSavedOutputRequest.store_layers)
}
inline void SpireSavedOutputRequest::add_store_layers(const char* value, size_t size) {
  store_layers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SpireSavedOutputRequest.store_layers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SpireSavedOutputRequest::store_layers() const {
  // @@protoc_insertion_point(field_list:SpireSavedOutputRequest.store_layers)
  return store_layers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SpireSavedOutputRequest::mutable_store_layers() {
  // @@protoc_insertion_point(field_mutable_list:SpireSavedOutputRequest.store_layers)
  return &store_layers_;
}

// bool reduce_num_views = 4;
inline void SpireSavedOutputRequest::clear_reduce_num_views() {
  reduce_num_views_ = false;
}
inline bool SpireSavedOutputRequest::reduce_num_views() const {
  // @@protoc_insertion_point(field_get:SpireSavedOutputRequest.reduce_num_views)
  return reduce_num_views_;
}
inline void SpireSavedOutputRequest::set_reduce_num_views(bool value) {
  
  reduce_num_views_ = value;
  // @@protoc_insertion_point(field_set:SpireSavedOutputRequest.reduce_num_views)
}

// bool reduce_output_space = 5;
inline void SpireSavedOutputRequest::clear_reduce_output_space() {
  reduce_output_space_ = false;
}
inline bool SpireSavedOutputRequest::reduce_output_space() const {
  // @@protoc_insertion_point(field_get:SpireSavedOutputRequest.reduce_output_space)
  return reduce_output_space_;
}
inline void SpireSavedOutputRequest::set_reduce_output_space(bool value) {
  
  reduce_output_space_ = value;
  // @@protoc_insertion_point(field_set:SpireSavedOutputRequest.reduce_output_space)
}

// float fps = 6;
inline void SpireSavedOutputRequest::clear_fps() {
  fps_ = 0;
}
inline float SpireSavedOutputRequest::fps() const {
  // @@protoc_insertion_point(field_get:SpireSavedOutputRequest.fps)
  return fps_;
}
inline void SpireSavedOutputRequest::set_fps(float value) {
  
  fps_ = value;
  // @@protoc_insertion_point(field_set:SpireSavedOutputRequest.fps)
}

// int32 topk = 7;
inline void SpireSavedOutputRequest::clear_topk() {
  topk_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpireSavedOutputRequest::topk() const {
  // @@protoc_insertion_point(field_get:SpireSavedOutputRequest.topk)
  return topk_;
}
inline void SpireSavedOutputRequest::set_topk(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  topk_ = value;
  // @@protoc_insertion_point(field_set:SpireSavedOutputRequest.topk)
}

// -------------------------------------------------------------------

// SpireSavedOutputResponse

// .ResponseStatus status = 1;
inline bool SpireSavedOutputResponse::has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline const ::ResponseStatus& SpireSavedOutputResponse::status() const {
  const ::ResponseStatus* p = status_;
  // @@protoc_insertion_point(field_get:SpireSavedOutputResponse.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::ResponseStatus*>(
      &::_ResponseStatus_default_instance_);
}
inline ::ResponseStatus* SpireSavedOutputResponse::release_status() {
  // @@protoc_insertion_point(field_release:SpireSavedOutputResponse.status)
  
  ::ResponseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ResponseStatus* SpireSavedOutputResponse::mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResponseStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireSavedOutputResponse.status)
  return status_;
}
inline void SpireSavedOutputResponse::set_allocated_status(::ResponseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:SpireSavedOutputResponse.status)
}

// .DataBatch results = 2;
inline bool SpireSavedOutputResponse::has_results() const {
  return this != internal_default_instance() && results_ != nullptr;
}
inline const ::DataBatch& SpireSavedOutputResponse::results() const {
  const ::DataBatch* p = results_;
  // @@protoc_insertion_point(field_get:SpireSavedOutputResponse.results)
  return p != nullptr ? *p : *reinterpret_cast<const ::DataBatch*>(
      &::_DataBatch_default_instance_);
}
inline ::DataBatch* SpireSavedOutputResponse::release_results() {
  // @@protoc_insertion_point(field_release:SpireSavedOutputResponse.results)
  
  ::DataBatch* temp = results_;
  results_ = nullptr;
  return temp;
}
inline ::DataBatch* SpireSavedOutputResponse::mutable_results() {
  
  if (results_ == nullptr) {
    auto* p = CreateMaybeMessage<::DataBatch>(GetArenaNoVirtual());
    results_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireSavedOutputResponse.results)
  return results_;
}
inline void SpireSavedOutputResponse::set_allocated_results(::DataBatch* results) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(results_);
  }
  if (results) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      results = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, results, submessage_arena);
    }
    
  } else {
    
  }
  results_ = results;
  // @@protoc_insertion_point(field_set_allocated:SpireSavedOutputResponse.results)
}

// -------------------------------------------------------------------

// SpireInstanceSegmentRequest

// .RequestMeta meta = 1;
inline bool SpireInstanceSegmentRequest::has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline const ::RequestMeta& SpireInstanceSegmentRequest::meta() const {
  const ::RequestMeta* p = meta_;
  // @@protoc_insertion_point(field_get:SpireInstanceSegmentRequest.meta)
  return p != nullptr ? *p : *reinterpret_cast<const ::RequestMeta*>(
      &::_RequestMeta_default_instance_);
}
inline ::RequestMeta* SpireInstanceSegmentRequest::release_meta() {
  // @@protoc_insertion_point(field_release:SpireInstanceSegmentRequest.meta)
  
  ::RequestMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::RequestMeta* SpireInstanceSegmentRequest::mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::RequestMeta>(GetArenaNoVirtual());
    meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireInstanceSegmentRequest.meta)
  return meta_;
}
inline void SpireInstanceSegmentRequest::set_allocated_meta(::RequestMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:SpireInstanceSegmentRequest.meta)
}

// .DataBatch data = 2;
inline bool SpireInstanceSegmentRequest::has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline const ::DataBatch& SpireInstanceSegmentRequest::data() const {
  const ::DataBatch* p = data_;
  // @@protoc_insertion_point(field_get:SpireInstanceSegmentRequest.data)
  return p != nullptr ? *p : *reinterpret_cast<const ::DataBatch*>(
      &::_DataBatch_default_instance_);
}
inline ::DataBatch* SpireInstanceSegmentRequest::release_data() {
  // @@protoc_insertion_point(field_release:SpireInstanceSegmentRequest.data)
  
  ::DataBatch* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::DataBatch* SpireInstanceSegmentRequest::mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DataBatch>(GetArenaNoVirtual());
    data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireInstanceSegmentRequest.data)
  return data_;
}
inline void SpireInstanceSegmentRequest::set_allocated_data(::DataBatch* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:SpireInstanceSegmentRequest.data)
}

// repeated .SpireOps ops = 3;
inline int SpireInstanceSegmentRequest::ops_size() const {
  return ops_.size();
}
inline void SpireInstanceSegmentRequest::clear_ops() {
  ops_.Clear();
}
inline ::SpireOps SpireInstanceSegmentRequest::ops(int index) const {
  // @@protoc_insertion_point(field_get:SpireInstanceSegmentRequest.ops)
  return static_cast< ::SpireOps >(ops_.Get(index));
}
inline void SpireInstanceSegmentRequest::set_ops(int index, ::SpireOps value) {
  ops_.Set(index, value);
  // @@protoc_insertion_point(field_set:SpireInstanceSegmentRequest.ops)
}
inline void SpireInstanceSegmentRequest::add_ops(::SpireOps value) {
  ops_.Add(value);
  // @@protoc_insertion_point(field_add:SpireInstanceSegmentRequest.ops)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SpireInstanceSegmentRequest::ops() const {
  // @@protoc_insertion_point(field_list:SpireInstanceSegmentRequest.ops)
  return ops_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SpireInstanceSegmentRequest::mutable_ops() {
  // @@protoc_insertion_point(field_mutable_list:SpireInstanceSegmentRequest.ops)
  return &ops_;
}

// int32 topk = 4;
inline void SpireInstanceSegmentRequest::clear_topk() {
  topk_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpireInstanceSegmentRequest::topk() const {
  // @@protoc_insertion_point(field_get:SpireInstanceSegmentRequest.topk)
  return topk_;
}
inline void SpireInstanceSegmentRequest::set_topk(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  topk_ = value;
  // @@protoc_insertion_point(field_set:SpireInstanceSegmentRequest.topk)
}

// float fps = 5;
inline void SpireInstanceSegmentRequest::clear_fps() {
  fps_ = 0;
}
inline float SpireInstanceSegmentRequest::fps() const {
  // @@protoc_insertion_point(field_get:SpireInstanceSegmentRequest.fps)
  return fps_;
}
inline void SpireInstanceSegmentRequest::set_fps(float value) {
  
  fps_ = value;
  // @@protoc_insertion_point(field_set:SpireInstanceSegmentRequest.fps)
}

// repeated .Tag tags_to_watch = 6;
inline int SpireInstanceSegmentRequest::tags_to_watch_size() const {
  return tags_to_watch_.size();
}
inline ::Tag* SpireInstanceSegmentRequest::mutable_tags_to_watch(int index) {
  // @@protoc_insertion_point(field_mutable:SpireInstanceSegmentRequest.tags_to_watch)
  return tags_to_watch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag >*
SpireInstanceSegmentRequest::mutable_tags_to_watch() {
  // @@protoc_insertion_point(field_mutable_list:SpireInstanceSegmentRequest.tags_to_watch)
  return &tags_to_watch_;
}
inline const ::Tag& SpireInstanceSegmentRequest::tags_to_watch(int index) const {
  // @@protoc_insertion_point(field_get:SpireInstanceSegmentRequest.tags_to_watch)
  return tags_to_watch_.Get(index);
}
inline ::Tag* SpireInstanceSegmentRequest::add_tags_to_watch() {
  // @@protoc_insertion_point(field_add:SpireInstanceSegmentRequest.tags_to_watch)
  return tags_to_watch_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag >&
SpireInstanceSegmentRequest::tags_to_watch() const {
  // @@protoc_insertion_point(field_list:SpireInstanceSegmentRequest.tags_to_watch)
  return tags_to_watch_;
}

// -------------------------------------------------------------------

// SpireInstanceSegmentResponse

// .ResponseStatus status = 1;
inline bool SpireInstanceSegmentResponse::has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline const ::ResponseStatus& SpireInstanceSegmentResponse::status() const {
  const ::ResponseStatus* p = status_;
  // @@protoc_insertion_point(field_get:SpireInstanceSegmentResponse.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::ResponseStatus*>(
      &::_ResponseStatus_default_instance_);
}
inline ::ResponseStatus* SpireInstanceSegmentResponse::release_status() {
  // @@protoc_insertion_point(field_release:SpireInstanceSegmentResponse.status)
  
  ::ResponseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ResponseStatus* SpireInstanceSegmentResponse::mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResponseStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireInstanceSegmentResponse.status)
  return status_;
}
inline void SpireInstanceSegmentResponse::set_allocated_status(::ResponseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:SpireInstanceSegmentResponse.status)
}

// .DataBatch results = 2;
inline bool SpireInstanceSegmentResponse::has_results() const {
  return this != internal_default_instance() && results_ != nullptr;
}
inline const ::DataBatch& SpireInstanceSegmentResponse::results() const {
  const ::DataBatch* p = results_;
  // @@protoc_insertion_point(field_get:SpireInstanceSegmentResponse.results)
  return p != nullptr ? *p : *reinterpret_cast<const ::DataBatch*>(
      &::_DataBatch_default_instance_);
}
inline ::DataBatch* SpireInstanceSegmentResponse::release_results() {
  // @@protoc_insertion_point(field_release:SpireInstanceSegmentResponse.results)
  
  ::DataBatch* temp = results_;
  results_ = nullptr;
  return temp;
}
inline ::DataBatch* SpireInstanceSegmentResponse::mutable_results() {
  
  if (results_ == nullptr) {
    auto* p = CreateMaybeMessage<::DataBatch>(GetArenaNoVirtual());
    results_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireInstanceSegmentResponse.results)
  return results_;
}
inline void SpireInstanceSegmentResponse::set_allocated_results(::DataBatch* results) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(results_);
  }
  if (results) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      results = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, results, submessage_arena);
    }
    
  } else {
    
  }
  results_ = results;
  // @@protoc_insertion_point(field_set_allocated:SpireInstanceSegmentResponse.results)
}

// -------------------------------------------------------------------

// SpireDetectEmbedTagRequest

// .RequestMeta meta = 1;
inline bool SpireDetectEmbedTagRequest::has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline const ::RequestMeta& SpireDetectEmbedTagRequest::meta() const {
  const ::RequestMeta* p = meta_;
  // @@protoc_insertion_point(field_get:SpireDetectEmbedTagRequest.meta)
  return p != nullptr ? *p : *reinterpret_cast<const ::RequestMeta*>(
      &::_RequestMeta_default_instance_);
}
inline ::RequestMeta* SpireDetectEmbedTagRequest::release_meta() {
  // @@protoc_insertion_point(field_release:SpireDetectEmbedTagRequest.meta)
  
  ::RequestMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::RequestMeta* SpireDetectEmbedTagRequest::mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::RequestMeta>(GetArenaNoVirtual());
    meta_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireDetectEmbedTagRequest.meta)
  return meta_;
}
inline void SpireDetectEmbedTagRequest::set_allocated_meta(::RequestMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:SpireDetectEmbedTagRequest.meta)
}

// .DataBatch data = 2;
inline bool SpireDetectEmbedTagRequest::has_data() const {
  return this != internal_default_instance() && data_ != nullptr;
}
inline const ::DataBatch& SpireDetectEmbedTagRequest::data() const {
  const ::DataBatch* p = data_;
  // @@protoc_insertion_point(field_get:SpireDetectEmbedTagRequest.data)
  return p != nullptr ? *p : *reinterpret_cast<const ::DataBatch*>(
      &::_DataBatch_default_instance_);
}
inline ::DataBatch* SpireDetectEmbedTagRequest::release_data() {
  // @@protoc_insertion_point(field_release:SpireDetectEmbedTagRequest.data)
  
  ::DataBatch* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::DataBatch* SpireDetectEmbedTagRequest::mutable_data() {
  
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DataBatch>(GetArenaNoVirtual());
    data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireDetectEmbedTagRequest.data)
  return data_;
}
inline void SpireDetectEmbedTagRequest::set_allocated_data(::DataBatch* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:SpireDetectEmbedTagRequest.data)
}

// repeated .SpireOps ops = 3;
inline int SpireDetectEmbedTagRequest::ops_size() const {
  return ops_.size();
}
inline void SpireDetectEmbedTagRequest::clear_ops() {
  ops_.Clear();
}
inline ::SpireOps SpireDetectEmbedTagRequest::ops(int index) const {
  // @@protoc_insertion_point(field_get:SpireDetectEmbedTagRequest.ops)
  return static_cast< ::SpireOps >(ops_.Get(index));
}
inline void SpireDetectEmbedTagRequest::set_ops(int index, ::SpireOps value) {
  ops_.Set(index, value);
  // @@protoc_insertion_point(field_set:SpireDetectEmbedTagRequest.ops)
}
inline void SpireDetectEmbedTagRequest::add_ops(::SpireOps value) {
  ops_.Add(value);
  // @@protoc_insertion_point(field_add:SpireDetectEmbedTagRequest.ops)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SpireDetectEmbedTagRequest::ops() const {
  // @@protoc_insertion_point(field_list:SpireDetectEmbedTagRequest.ops)
  return ops_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SpireDetectEmbedTagRequest::mutable_ops() {
  // @@protoc_insertion_point(field_mutable_list:SpireDetectEmbedTagRequest.ops)
  return &ops_;
}

// int32 topk = 4;
inline void SpireDetectEmbedTagRequest::clear_topk() {
  topk_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpireDetectEmbedTagRequest::topk() const {
  // @@protoc_insertion_point(field_get:SpireDetectEmbedTagRequest.topk)
  return topk_;
}
inline void SpireDetectEmbedTagRequest::set_topk(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  topk_ = value;
  // @@protoc_insertion_point(field_set:SpireDetectEmbedTagRequest.topk)
}

// float fps = 5;
inline void SpireDetectEmbedTagRequest::clear_fps() {
  fps_ = 0;
}
inline float SpireDetectEmbedTagRequest::fps() const {
  // @@protoc_insertion_point(field_get:SpireDetectEmbedTagRequest.fps)
  return fps_;
}
inline void SpireDetectEmbedTagRequest::set_fps(float value) {
  
  fps_ = value;
  // @@protoc_insertion_point(field_set:SpireDetectEmbedTagRequest.fps)
}

// repeated .Tag tags_to_watch = 6;
inline int SpireDetectEmbedTagRequest::tags_to_watch_size() const {
  return tags_to_watch_.size();
}
inline ::Tag* SpireDetectEmbedTagRequest::mutable_tags_to_watch(int index) {
  // @@protoc_insertion_point(field_mutable:SpireDetectEmbedTagRequest.tags_to_watch)
  return tags_to_watch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag >*
SpireDetectEmbedTagRequest::mutable_tags_to_watch() {
  // @@protoc_insertion_point(field_mutable_list:SpireDetectEmbedTagRequest.tags_to_watch)
  return &tags_to_watch_;
}
inline const ::Tag& SpireDetectEmbedTagRequest::tags_to_watch(int index) const {
  // @@protoc_insertion_point(field_get:SpireDetectEmbedTagRequest.tags_to_watch)
  return tags_to_watch_.Get(index);
}
inline ::Tag* SpireDetectEmbedTagRequest::add_tags_to_watch() {
  // @@protoc_insertion_point(field_add:SpireDetectEmbedTagRequest.tags_to_watch)
  return tags_to_watch_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Tag >&
SpireDetectEmbedTagRequest::tags_to_watch() const {
  // @@protoc_insertion_point(field_list:SpireDetectEmbedTagRequest.tags_to_watch)
  return tags_to_watch_;
}

// float detection_score_threshold = 7;
inline void SpireDetectEmbedTagRequest::clear_detection_score_threshold() {
  detection_score_threshold_ = 0;
}
inline float SpireDetectEmbedTagRequest::detection_score_threshold() const {
  // @@protoc_insertion_point(field_get:SpireDetectEmbedTagRequest.detection_score_threshold)
  return detection_score_threshold_;
}
inline void SpireDetectEmbedTagRequest::set_detection_score_threshold(float value) {
  
  detection_score_threshold_ = value;
  // @@protoc_insertion_point(field_set:SpireDetectEmbedTagRequest.detection_score_threshold)
}

// -------------------------------------------------------------------

// SpireDetectEmbedTagResponse

// .ResponseStatus status = 1;
inline bool SpireDetectEmbedTagResponse::has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline const ::ResponseStatus& SpireDetectEmbedTagResponse::status() const {
  const ::ResponseStatus* p = status_;
  // @@protoc_insertion_point(field_get:SpireDetectEmbedTagResponse.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::ResponseStatus*>(
      &::_ResponseStatus_default_instance_);
}
inline ::ResponseStatus* SpireDetectEmbedTagResponse::release_status() {
  // @@protoc_insertion_point(field_release:SpireDetectEmbedTagResponse.status)
  
  ::ResponseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::ResponseStatus* SpireDetectEmbedTagResponse::mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::ResponseStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireDetectEmbedTagResponse.status)
  return status_;
}
inline void SpireDetectEmbedTagResponse::set_allocated_status(::ResponseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:SpireDetectEmbedTagResponse.status)
}

// .DataBatch results = 2;
inline bool SpireDetectEmbedTagResponse::has_results() const {
  return this != internal_default_instance() && results_ != nullptr;
}
inline const ::DataBatch& SpireDetectEmbedTagResponse::results() const {
  const ::DataBatch* p = results_;
  // @@protoc_insertion_point(field_get:SpireDetectEmbedTagResponse.results)
  return p != nullptr ? *p : *reinterpret_cast<const ::DataBatch*>(
      &::_DataBatch_default_instance_);
}
inline ::DataBatch* SpireDetectEmbedTagResponse::release_results() {
  // @@protoc_insertion_point(field_release:SpireDetectEmbedTagResponse.results)
  
  ::DataBatch* temp = results_;
  results_ = nullptr;
  return temp;
}
inline ::DataBatch* SpireDetectEmbedTagResponse::mutable_results() {
  
  if (results_ == nullptr) {
    auto* p = CreateMaybeMessage<::DataBatch>(GetArenaNoVirtual());
    results_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SpireDetectEmbedTagResponse.results)
  return results_;
}
inline void SpireDetectEmbedTagResponse::set_allocated_results(::DataBatch* results) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(results_);
  }
  if (results) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      results = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, results, submessage_arena);
    }
    
  } else {
    
  }
  results_ = results;
  // @@protoc_insertion_point(field_set_allocated:SpireDetectEmbedTagResponse.results)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SpireConfig_Framework> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SpireConfig_Framework>() {
  return ::SpireConfig_Framework_descriptor();
}
template <> struct is_proto_enum< ::SpireModelType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SpireModelType>() {
  return ::SpireModelType_descriptor();
}
template <> struct is_proto_enum< ::SpireSpatialReduceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SpireSpatialReduceType>() {
  return ::SpireSpatialReduceType_descriptor();
}
template <> struct is_proto_enum< ::SpireState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SpireState>() {
  return ::SpireState_descriptor();
}
template <> struct is_proto_enum< ::SpireOps> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SpireOps>() {
  return ::SpireOps_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fspire_2fspire_2eproto
